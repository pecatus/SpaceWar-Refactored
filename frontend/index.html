<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SpaceWar</title>
    <link rel="stylesheet" href="tailwind-build.css" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tween.js/20.0.3/tween.umd.js"></script>
    <script>
        /*================================================================
        ai_logic.js  –  AI‑logiikka & utility‑funktiot  (v13 –  yksi rakennus per planeetta)
        ================================================================================*/

        /************************  0)  Modulaarinen kääre  ************************/
        (()=>{

        /********************** 1)  Globaalit & apurifunktiot **********************/
        const uuid = (typeof crypto !== 'undefined' && crypto.randomUUID)
                    ? () => crypto.randomUUID()
                    : () => 'id_' + Math.random().toString(36).slice(2);

        // Pelaaja-ID:t
        const PLAYER_ID = window.PLAYER_ID || 'player';

        // Nopeus-fallbackit
        const SPEED_FAST         = window.SHIP_SPEED_FAST    ?? 60;
        const SPEED_SLOW         = window.SHIP_SPEED_SLOW    ?? 6;
        const FIGHTER_SPEED_SLOW = window.FIGHTER_SPEED_SLOW ?? 12;

        // Starlane-pisteytys (planeetan arvottamiseen)
        const STARLANE_BONUS = 8;
        const NONLANE_FACTOR = 1.35;

        // Fleet-parametrit
        const LAUNCH_MIN    = 1;
        const FLEET_TARGET  = 8;

        function shipPower(ship){
            return ship.type === 'Fighter'   ? 1 :
                ship.type === 'Destroyer'? 2 :
                ship.type === 'Slipstream Frigate' ? 0 :
                /* Cruiser */              3;
        }

        function starThreatScore(star, hostileShips){
            const pdShots = star.defenseLevel * 3;
            const hostile = [...hostileShips].sort((a,b)=>shipPower(b)-shipPower(a));
            for(let i=0;i<pdShots && hostile.length;i++) hostile.shift();
            return hostile.reduce((s,sh)=>s + shipPower(sh), 0);
        }

        /* ===== AI:n BUDJETTI KOLMEEN LOMPAKKOON  ====================================== */

        const WAIT_THRESHOLD = 0.60;              // 60 % säästöraja (alle 60% säästössä => ei säästetä)
        const EXPENSIVE_PLANETARY_TAGS = [
            'Shipyard', 'Infrastructure Lvl', 'Defense Upgrade'
            ];
        const EXPENSIVE_SHIP_TAGS = [ 'Cruiser', 'Destroyer' ];

        /*  Jaa rahat tilanteen mukaan */
        function budgetShares(totalMines){
        if (totalMines < 5)   return {eco:0.40, tech:0.10, war:0.50}; // Aivan ensimmäisellä AI-tickillä aloitusrahat ja -resurssit jaetaan kolmeen lompakkoon. Riittävät 10 mine ja 10 fighter ja pesämuna techiin
        if (totalMines < 15)   return {eco:0.40, tech:0.10, war:0.50}; // Nyt techiinkin jo hieman pesämunaa alkuun tasaista tahtia aluksia ja kaivoksia noin 15 ja 15 
        if (totalMines < 30)   return {eco:0.50, tech:0.20, war:0.30}; // kiihdytetään kaivostuotantoa unohtamatta aluksia
        if (totalMines < 45)   return {eco:0.20, tech:0.45, war:0.35}; // kaivoksia jo paljon, satsataan planeettakehitykseen
        if (totalMines < 60)   return {eco:0.10, tech:0.35, war:0.55}; // kaivoksia taatusti riittävästi, sotakone päälle taas
                                return {eco:0.05, tech:0.25, war:0.70}; // endgame -> sota
        }

        // Telakoille diminishing returns prioriteettipainotuksiin jokaisesta rakennetusta telakasta
        function shipyardDiminish(myStars = []) {
            const built = myStars.filter(s => s.shipyardLevel > 0).length;
            // 1 telakka = 1.0   …  2 = 0.7  …  3 = 0.5  … 4+ = 0.3
            if   (built <= 1) return 1.0;
            else if (built === 2) return 0.5;
            else if (built === 3) return 0.2;
            return 0.05;
        }

        // Kuinka paljon kaivosslotteja jäljellä? 0-1 skaala
        function mineRoomScale(star){
            const lim   = window.INFRA_LIMITS[star.infrastructureLevel].maxMines;
            const built = star.mines + queuedCount(star,'Mine');

            if (built === 0) return 0;            // älä kehitä "tyhjää" planeettaa
            const free = lim - built;
            if (free <= 0) return 0;

            return Math.min(1, free/5 + 0.2);     // 1.0 … 0.2 lineaarinen asteikko
            }

        /* Tee lompakot yhdelle vuorolle */
        function makeBudget3(res, totalMines){
        const s = budgetShares(totalMines);
        return {
            eco : {credits: res.credits*s.eco , minerals: res.minerals*s.eco },
            tech: {credits: res.credits*s.tech, minerals: res.minerals*s.tech},
            war : {credits: res.credits*s.war , minerals: res.minerals*s.war }
        };
        }

        /* apurit */
        const affordable = (cost,w) =>
            w.credits >= cost.credits && w.minerals >= cost.minerals;

        function pay(cost, wallet, res, name, aiId) {
        wallet.credits  -= cost.credits;
        wallet.minerals -= cost.minerals;
        res.credits     -= cost.credits;
        res.minerals    -= cost.minerals;
        // console.log(
        //    `[AI-${aiId}-pay] from ${name}  -${cost.credits}/${cost.minerals}` +
        //    ` → ${wallet.credits.toFixed(1)}/${wallet.minerals.toFixed(1)}`
        //);
        }


        /* queuedCount - montako samaa tyyppiä planetaarisessa jonossa */
        const queuedCount = (star, type) =>
        (star?.planetaryConstructionQueue || []).filter(it => it.type === type).length;

        const effective = s => ({
        mines   : s.mines         + queuedCount(s,'Mine'),
        defense : s.defenseLevel  + queuedCount(s,'Defense Upgrade'),
        yard    : s.shipyardLevel + queuedCount(s,'Shipyard Lvl')
        });

        const EARLY_STEPS = [
        //{ mines:30, weights:{Mine:0.25, Fighter:0.25, Infrastructure:0.25, Shipyard:0.25} },
        //{ mines:25, weights:{Mine:0.30, Fighter:0.60, Infrastructure:0.25, Shipyard:0.10} },
        { mines:20, weights:{Mine:0.40, Fighter:0.50, Infrastructure:0.10, Shipyard:0.00} },
        { mines:15, weights:{Mine:0.50, Fighter:0.50, Infrastructure:0.00, Shipyard:0.00} },
        { mines:10, weights:{Mine:0.60, Fighter:0.40, Infrastructure:0.00, Shipyard:0.00} },
        { mines: 5, weights:{Mine:0.70, Fighter:0.30, Infrastructure:0.00, Shipyard:0.00} },
        { mines: 0, weights:{Mine:1.00, Fighter:0.00, Infrastructure:0.00, Shipyard:0.00} }
        ];

        function currentWarReserve(totalShips){
            if (totalShips < 10) return {credits:50,  minerals:25};
            if (totalShips < 20) return {credits:75,  minerals:25};
            if (totalShips < 30) return {credits:150,  minerals:50};
            if (totalShips < 40) return {credits:200,  minerals:100};
                                return {credits:300, minerals:200};
        }

        function getGlobalPlayerFleet(allShips, playerId){
        return {
            fighters  : allShips.filter(s=>s.owner===playerId && s.type==='Fighter').length,
            destroyers: allShips.filter(s=>s.owner===playerId && s.type==='Destroyer').length,
            cruisers  : allShips.filter(s=>s.owner===playerId && s.type==='Cruiser').length,
            total     : allShips.filter(s=>s.owner===playerId).length
        };
        }

        /* ---------------------------------------------------
        +   Palauta kuhunkin kaivosmmäärään kuuluva painojoukko
        +--------------------------------------------------- */
        function currentEarlyWeights(totalMines){
            // Kun kaivoksia on riittävästi, älä enää käytä early-painoja
            if (totalMines >= 25) return null;

            // Käydään listaa ylhäältä alas; palautetaan ensimmäinen osuma
            for (const step of EARLY_STEPS){
                if (totalMines >= step.mines) return step.weights;
            }
            return null;   // varmuuskopio
        }


        /********************** 2)  Pisteytykset & kustannus-taulukot **************/
        // Infra ja telakat tärkeämpiä!
        const WEIGHTS = {
            'Mine': 1, 
            'Defense Upgrade': 2, 
            'Shipyard': 1,           
            'Shipyard Upgrade': 1.2,   
            'Infrastructure': 1.3,      
            Fighter: 0.45, 
            Destroyer: 0.75, 
            Cruiser: 1.5
        };

        const STRUCT_COST = {
        'Mine':[75,25,10], 'Defense Upgrade':[100,50,15],
        'Shipyard Lvl 1':[150,100,20], 'Shipyard Lvl 2':[250,200,40], 'Shipyard Lvl 3':[325,260,60]
        };

        // [credits, minerals, buildTime, minShipyardLevel]
        const SHIP_COST = {
        Fighter  :[50,25,10,1],
        Destroyer:[100,50,25,2],
        Cruiser  :[150,75,45,3],
        'Slipstream Frigate': [120, 180, 55, 4]
        };
        window.SHIP_COST = SHIP_COST;

        /* ---- CREDIT UPKEEP ------------------------------------------------ */
        // /10 s  (yksi resurssi-tick)
        const UPKEEP_SHIP      = { Fighter: 1, Destroyer: 2, Cruiser: 3, 'Slipstream Frigate': 4 };
        const UPKEEP_PD        = 2;   // /defense-lvl
        const UPKEEP_SHIPYARD  = 3;   // /shipyard-lvl

        // ---- EXPORT TO GLOBAL SCOPE ----
        window.UPKEEP_SHIP     = UPKEEP_SHIP;
        window.UPKEEP_PD       = UPKEEP_PD;
        window.UPKEEP_SHIPYARD = UPKEEP_SHIPYARD;

        // APUFUNKTIOT

        /* Paljonko infra-tasoja on jo jonossa? */
        function infraUpgradesQueued(star) {
            return star.planetaryConstructionQueue
                    .filter(it => it.type.startsWith('Infrastructure')).length;
        }

        /* Paljonko telakka-tasoja on jo jonossa? */
        function shipyardUpgradesQueued(star) {
            return star.planetaryConstructionQueue
                    .filter(it => it.type.startsWith('Shipyard')).length;
        }

        /* "Todellinen" taso = valmis + jonossa */
        function effectiveInfraLevel(star) {
            return star.infrastructureLevel + infraUpgradesQueued(star);
        }

        function effectiveShipyardLevel(star) {
            return star.shipyardLevel + shipyardUpgradesQueued(star);
        }

        /* Infra-kustannukset */
        function infraCost(currentLevel){
            return shipyardCost(currentLevel);   
        }

        /* Telakka-kustannukset */
        function shipyardCost(currentLevel) {
            if (currentLevel === 0) {
                return { nextLevel: 1, credits: 150, minerals: 100, time: 20 };
            }
            const base = { c: 150, m: 100, t: 40 };
            const factor = 1 + 0.3 * currentLevel;
            return {
                nextLevel: currentLevel + 1,
                credits: Math.round(base.c * factor),
                minerals: Math.round(base.m * factor),
                time: Math.round(base.t * factor)
            };
        }

        // Planetary defense tarpeen laskemisen apufunktio
        function wantedDefense(star, yardFuture){
            const lvl = star.infrastructureLevel;

            /*   Tavoite-taulukko
                ----------------
                Infra 1  :  1  (jos telakka)  / 0 (ilman telakkaa)
                Infra 2  :  2
                Infra 3  :  2  (+telakka → 3)
                Infra 4+ :  4  (+telakka → 6)   */
            if (lvl < 2)  return yardFuture > 0 ? 1 : 0;
            if (lvl === 2) return 2;
            if (lvl === 3) return yardFuture > 0 ? 3 : 2;
            // lvl ≥ 4
            return yardFuture > 0 ? 6 : 4;
            }


        /* Pisteytys-funktio - päivitetty logiikka */
        function scoreBuild(star, type) {
            const e = effective(star);
            const lim = window.INFRA_LIMITS[effectiveInfraLevel(star)];
            
            // Perustarkistukset
            if (type === 'Mine' && e.mines >= lim.maxMines) return 0;
            if (type === 'Defense Upgrade' && e.defense >= lim.maxDefense) return 0;
            if (type.startsWith('Shipyard') && e.yard >= lim.maxShipyard) return 0;
            
            // Jonot täynnä?
            const fullPlan = star.planetaryConstructionQueue.length > 4;
            const fullShip = star.shipConstructionQueue.length > 3;
            if (fullPlan && (type === 'Mine' || type === 'Defense Upgrade' || type.startsWith('Shipyard') || type.startsWith('Infrastructure'))) return 0;
            if (fullShip && (type === 'Fighter' || type === 'Destroyer' || type === 'Cruiser')) return 0;
            
            let score = 0;
            
            if (type === 'Mine') {
                // Priorisoi kaivoksia jos niitä on vähän
                const ratio = e.mines / Math.max(1, lim.maxMines);
                score = WEIGHTS['Mine'] * (1 - ratio) * 1.5; // Suurempi bonus kun vähemmän kaivoksia

            } else if (type.startsWith('Infrastructure')) {
                // Infra on TÄRKEÄ // Oli aiemmin shipyhardin alapuolella, nyt yläpuolella. 
                // Infra = tärkein kun infra < 3
                /* ✱ Älä kehitä kiveä jolla ei ole kaivosta TAI telakkaa */
                const hasMine = star.mines + queuedCount(star,'Mine') > 0;
                const yardNow = star.shipyardLevel > 0 || shipyardUpgradesQueued(star);
                if (!hasMine && !yardNow) return 0;

                score = WEIGHTS['Infrastructure'] * (4 - star.infrastructureLevel);
                if (star.shipyardLevel > 0) score *= 1.8;      // telakka-bonus
                if (hasMine)                score *= 1.8;      // kaivos-bonus

                /* ✱ VAIMENNUS: jos infra jo 3 ja telakka vielä alle 2, odotetaan
                    infra4-päivityksen kanssa */
                if (star.infrastructureLevel >= 2 && star.shipyardLevel < 2) {
                    score *= 0.1;             // tiputtaa infra4:n kauemmas listalla
                }
                else if (star.infrastructureLevel >= 3 && star.shipyardLevel < 3) {
                    score *= 0.1;             // tiputtaa infra4:n kauemmas listalla
                }

            } else if (type === 'Shipyard' || type.startsWith('Shipyard Lvl')) {
                // --- A) uusi telakka ---------------------------------------
                if (star.shipyardLevel === 0 && !shipyardUpgradesQueued(star)) {

                    // diminishing returns koskee VAIN uusia telakoita
                    const dim = shipyardDiminish(
                        (window.stars || []).filter(s => s.owner === star.owner)
                    );
                    score = WEIGHTS['Shipyard'] * dim;

                // --- B) telakan päivitys ------------------------------------
                } else {
                    // ei dim-kerrointa -> päivitys pysyy korkealla listalla
                    score = WEIGHTS['Shipyard Upgrade'] * (3 - star.shipyardLevel);

                    // extra-boost juuri lvl 2 → 3 päivitykselle
                    if (star.shipyardLevel === 2) score *= 3;
                }

                /* ❸ Lisäboosti, jos infra on jo korkea mutta telakka matala */
                if (star.infrastructureLevel >= 3 && star.shipyardLevel < 2) {
                    score *= 2.5;
                }

            } else if (type === 'Defense Upgrade') {
                /* -------------------------------------------------
                Puolustetaan vain "arvokkaita" planeettoja
                ------------------------------------------------- */
                const yardFuture = effectiveShipyardLevel(star);   // valmis + jonossa
                const worthDefending =
                    yardFuture > 0               // telakka (valmis tai rakenteilla)
                || star.infrastructureLevel >= 2;  // tai infra≥2
                if (!worthDefending) return 0;

                /* b) Paljonko puuttuu? */
                const wanted  = wantedDefense(star, yardFuture);
                const queued  = queuedCount(star,'Defense Upgrade');
                const have    = star.defenseLevel;
                const missing = Math.max(0, wanted - (have + queued));
                if (missing === 0) return 0;

                /* c) pisteytys */
            let base = WEIGHTS['Defense Upgrade'] * missing;   // enemmän puuttuu → isompi

                /* Painokerroin kasvaa arvon mukaan */
                if      (star.infrastructureLevel >= 4) base *= 4.0;
                else if (star.infrastructureLevel === 3) base *= 3.0;
                else if (yardFuture > 0)                 base *= 2.0;

                score = base;
            }
            
            // Bonukset
            if (!star.isHomeworld) score *= 1.3; // Kehitä muita planeettoja!
            if (star.connections.length > 2) score *= 1.2; // Solmukohdat
            if (star.shipyardLevel === 0 && type !== 'Shipyard') score *= 0.1; // Priorisoi telakkaa!
            
            return score;
        }

        /* -------------------------------------------------------------
        Reorderoi planetaarinen rakennusjono pisteiden (scoreBuild)
        perusteella – paras ensin, huonoin viimeiseksi
        ------------------------------------------------------------- */
        function reorderQueue(star) {
            if (!star.planetaryConstructionQueue || star.planetaryConstructionQueue.length < 2) return;

            star.planetaryConstructionQueue.sort((a, b) =>
                scoreBuild(star, b.type) - scoreBuild(star, a.type)
            );
        }

        /************************ 3)  AIController ******************************/
        const PHASE = { EXPAND:'EXPAND', DEFEND:'DEFEND' };

        class AIController {
        constructor(aiId, res, stars, allShips){
            this.aiId  = aiId;
            this.res   = res;
            this.stars = stars;
            this.allShips = allShips;
            this.turn  = 0;
            this.phase = PHASE.EXPAND;
            this.ecoBank  = { credits: 0, minerals: 0 };
            this.techBank = { credits: 0, minerals: 0 };
            this.warBank  = { credits: 0, minerals: 0 };
            this.prevRes = { credits: res.credits, minerals: res.minerals };
        }

        // Priorisoi planeetat kehitystarpeen mukaan
        prioritizePlanets(myStars) {
            return myStars.map(star => {
                let priority = 0;
                
                // Kehittymättömät planeetat saavat bonusta
                if (star.shipyardLevel === 0) priority += 2;
                if (star.infrastructureLevel === 1) priority += 2;
                if (star.mines < 3) priority += 10;
                
                // Strateginen arvo
                priority += star.connections.length * 3;
                priority += star.shipyardLevel * 2; // Vähemmän painoa olemassa oleville
                
                // Kehityspotentiaali
                const limits = window.INFRA_LIMITS[star.infrastructureLevel];
                const developmentRoom = (limits.maxMines - star.mines) + 
                                    (limits.maxPop - star.population) +
                                    (3 - star.shipyardLevel) * 5;
                priority += developmentRoom;
                
                // Uhanalaisuus - check all non-owner neighbors
                const enemyNeighbors = star.connections.filter(id => {
                    const neighbor = this.stars.find(s => s.id === id);
                    return neighbor && neighbor.owner !== this.aiId;
                }).length;
                priority += enemyNeighbors * 2;
                
                // Vähennä kotiplaneetan prioriteettia
                if (star.isHomeworld) priority *= 0.5;
                
                return { star, priority };
            }).sort((a, b) => b.priority - a.priority);
        }

        getRequiredMines(totalShips){
            const table = [
                { ships: 0, mines: 0 },
                { ships: 10, mines: 10 },
                { ships: 15, mines: 15 },
                { ships: 20, mines: 20 },
                { ships: 25, mines: 25 },
                { ships: 30, mines: 30 },
                { ships: 35, mines: 35 },
                { ships: 40, mines: 40 },
                { ships: 45, mines: 45 },
                { ships: 50, mines: 50 },   // turva-rivi, jos alle 10 alusta
            ];
            let req = 0;
            for (const row of table){
                if (totalShips >= row.ships) req = row.mines;
            }
            return req;   // korkein täytetty rivi
        }

        /** UUSI: Rakenna yksi asia per kierros, priorisoi oikein */
        buildOneThingPerTurn(myStars, totalMines, totalShips, budget){
            /* -------------------------------------------------
            globaali tilanne
            -------------------------------------------------*/
            //kaivosten määrä planeetalla antaa PD:lle painotuskertoimia puolustuksen rakentamiseksi
            function pdMineBonus(star){
                const lim = window.INFRA_LIMITS[star.infrastructureLevel].maxMines;
                if (lim === 0) return 1;             // varmuuden vuoksi
                const ratio = star.mines / lim;      // 0 … 1
                return 1 + ratio;                    // 1.0 – 2.0
                }

            /* ❶  EARLY-GAME painokertoimet taulukosta -------------- */
            const earlyW = currentEarlyWeights(totalMines);
            const dimShip = shipyardDiminish(myStars);

            function earlyWeightFor(type){
                // Jos earlyW on null → käytä oletuspainoa 1.0
                if (!earlyW) return 1;

                if (type.startsWith('Infrastructure')) return earlyW.Infrastructure ?? 1;
                if (type.startsWith('Shipyard'))       return earlyW.Shipyard       ?? 1;
                return earlyW[type] ?? 1;   // puuttuva avain = 1 (ei nollaa!)
            }

            /* -------------------------------------------------
            YHTENÄINEN lisäys: lisää listalle valinta, laske pisteet,
            loggaa kaikki kertoimet näkyviin (kommentoitu pois)
            ---------------------------------------------------*/
            function pushOption(list, star, type, cost, mult = 1) {
                const base  = scoreBuild(star, type);           // peruspiste
                const weight = earlyWeightFor(type);            // early-painokerroin
                const score  = base * weight * mult;            // lopullinen

                //console.log(
                //`%c[AI-${star.owner}-score] ${type} @ ${star.name}` +
                //`  base=${base.toFixed(2)}  w=${weight}` +
                //`  mult=${mult}  →  ${score.toFixed(2)}`,
                //'color:#6cf'
                // );

                list.push({ star, type, cost, score });
            }

            /* ❶  Kun kaivoksia < 5  → Rakenna _vain_ kaivoksia */
            if (totalMines < 5) {
                // Etsi lähin planeetta, jossa on tilaa kaivokselle
                const target = myStars
                    .filter(st => st.mines + queuedCount(st,'Mine') <
                                window.INFRA_LIMITS[st.infrastructureLevel].maxMines)
                    .sort((a,b) => a.mines - b.mines)[0];
                if (target && this.res.credits >= 75 && this.res.minerals >= 25) {
                    this.res.credits  -= 75;
                    this.res.minerals -= 25;
                    window.pushToPlanetaryQueue(target, {
                        type:'Mine', timeLeft:10, totalTime:10, id:`ai_mine_${uuid()}`
                    });
                    // console.log(`AI ${this.aiId} EARLY: Mine → ${target.name}`);
                    return true;      // rakennus tehty, poistutaan
                }
                return false;         // ei vielä rahaa → odota
            }

            /* ❷  Kun kaivoksia 1–9  JA  aluksia < 10  → rakennetaan laivoja */
            if (totalMines < 10 && totalShips < 10) {
                this.buildShipsSmartly(myStars, totalMines, totalShips, budget);
                return true;          // älä tee muuta tällä kierroksella
            }


            let builtSomething = false;



            /* -------------------------------------------------------------
            GLOBAALI KAIVOS-QUOTA  (kaivokset <-> alusten määrä)
            ------------------------------------------------------------- */

            const needMines     = this.getRequiredMines(totalShips);
            const mustBuildMine = totalMines < needMines;

            /* Kun quota on täynnä, kerro kaivoksen lopullista
                scorea 0.15:lla  → tiputtaa prioriteetin selvästi
                infraan / telakoihin verrattuna. */
            function mineScale() { return mustBuildMine ? 1 : 0.15; }

            /* 2)  kerää kaikki rakentamisvaihtoehdot ----------------------*/
            const allOptions = [];

            myStars.forEach(star => {

            /* ---------- Infrastructure ---------- */
            if (star.infrastructureLevel < 4 && !infraUpgradesQueued(star)){
                const ic = infraCost(star.infrastructureLevel);
            pushOption(
                allOptions,
                star,
                `Infrastructure Lvl ${ic.nextLevel}`,
                ic
            );
            }

            /* ---------- Shipyard (rakennus / upgrade) ---------- */
            if (star.shipyardLevel === 0 && !shipyardUpgradesQueued(star)){
            pushOption(
                allOptions,
                star,
                'Shipyard',
                { credits:150, minerals:100, time:20 },
                dimShip
            );
            } else if (star.shipyardLevel > 0 &&
                        star.shipyardLevel < window.INFRA_LIMITS[star.infrastructureLevel].maxShipyard &&
                        !shipyardUpgradesQueued(star)){
                const yc = shipyardCost(star.shipyardLevel);
                pushOption(
                    allOptions,
                    star,
                    `Shipyard Lvl ${yc.nextLevel}`,
                    yc,
                    dimShip
                );
            }

            /* ---------- Mine ---------- */
            if (star.mines < window.INFRA_LIMITS[star.infrastructureLevel].maxMines){
                pushOption(
                    allOptions,
                    star,
                    'Mine',
                    { credits:75, minerals:25, time:10 },
                    mineScale() * mineRoomScale(star)                  // mult-parametri
                );
            }

            /* ---------- Defense (pisteytys scoreBuild -funktiossa, kaivoskerroin-apuri heti tämän funktion alussa) ---------- */
            
            if (scoreBuild(star,'Defense Upgrade') > 0) {
                const pdMult =
                    (!mustBuildMine ? 1 : 0.4) *          // ↓ jos kaivos-puute, mieluummin mine
                    pdMineBonus(star);                    // ↑ jos kaivoksia paljon

                pushOption(
                    allOptions,
                    star,
                    'Defense Upgrade',
                    { credits: 100, minerals: 50, time: 15 },
                    pdMult
                );
            }
        });
            
            // Lajittele pisteiden mukaan
            allOptions.sort((a, b) => b.score - a.score);
            
                // 2) jos ei mitään vaihtoehtoja
                if (allOptions.length === 0) {
                    // console.log(`[AI ${this.aiId}] No build options available`);
                    return false;
                }

                // 3) etsi paras affordable & paras säästökohde
                let bestAffordable = null;
                let bestSaveTarget = null;

                for (const option of allOptions) {
                    const wallet =
                        option.type === 'Mine'                    ? this.ecoBank  :
                        option.type === 'Defense Upgrade'         ? this.techBank  :
                        option.type.startsWith('Shipyard') ||
                        option.type.startsWith('Infrastructure')  ? this.techBank :
                                                                    this.warBank;

                    const expensivePlanetary = EXPENSIVE_PLANETARY_TAGS
                            .some(tag => option.type.startsWith(tag));
                    const expensive = expensivePlanetary; 

                    if (affordable(option.cost, wallet)) {
                        if (!bestAffordable) bestAffordable = {option, wallet};
                    } else if (expensive &&
                            wallet.credits  >= WAIT_THRESHOLD*option.cost.credits &&
                            wallet.minerals >= WAIT_THRESHOLD*option.cost.minerals) {
                        if (!bestSaveTarget) bestSaveTarget = option;
                    }
                }

                // 4) päätös: rakennetaanko vai säästetäänkö
                if (bestAffordable) {
                    if (bestSaveTarget && bestSaveTarget.score > bestAffordable.option.score) {
                        // console.log(`[AI ${this.aiId}] Saving for ${bestSaveTarget.type} (score ${bestSaveTarget.score.toFixed(2)})`);
                        return false;           // ei rakenneta tällä vuorolla
                    }

                    // --- suorita osto ---
                    const {option, wallet} = bestAffordable;
                    const walletName = wallet === this.ecoBank ? 'eco'
                                    : wallet === this.techBank ? 'tech'
                                    : 'war';

                    pay(option.cost, wallet, this.res, walletName, this.aiId);

                    const queueItem = {
                        type      : option.type,
                        timeLeft  : option.cost.time,
                        totalTime : option.cost.time,
                        id        : `ai_${option.type.replace(/ /g,'_')}_${uuid()}`
                    };
                    if (option.type.startsWith('Infrastructure'))
                        queueItem.targetLevel = parseInt(option.type.match(/\d+/)[0]);
                    else if (option.type.startsWith('Shipyard'))
                        queueItem.targetLevel = option.type === 'Shipyard'
                                                ? 1
                                                : parseInt(option.type.match(/\d+/)[0]);

                    window.pushToPlanetaryQueue(option.star, queueItem);
                    // console.log(`AI ${this.aiId} Turn ${this.turn}: Built ${option.type} at ${option.star.name}`);
                    reorderQueue(option.star);
                    return true;
                }

                if (bestSaveTarget) {
                    // console.log(`[AI ${this.aiId}] Actively saving for ${bestSaveTarget.type} (score ${bestSaveTarget.score.toFixed(2)})`);
                    return false;
                }

                // console.log(`[AI ${this.aiId}] Could not build anything (no affordable options and nothing worth saving for)`);
                return false;
        }

        /** Rakenna laivoja järkevästi */
        buildShipsSmartly(myStars, totalMines, totalShips, budget) {
        const needMines     = this.getRequiredMines(totalShips);
        const mustBuildMine = totalMines < needMines;

        // ota talteen sodan lompakko
        const warWallet = this.warBank;
        const walletName = 'war';

        if (totalMines < needMines) {
            // console.log(`[AI ${this.aiId}] skip ship-build: mines ${totalMines}/${needMines}`);
            return;
        }
        if (warWallet.credits < 25 || warWallet.minerals < 12) return;

        const shipyardStars = myStars
            .filter(s => s.shipyardLevel > 0)
            .sort((a, b) => b.shipyardLevel - a.shipyardLevel);

        for (const star of shipyardStars) {
            if (star.shipConstructionQueue.length >= 2) continue;

            const fleet = this.getFleetComposition(star);
            const prio  = this.getShipBuildPriority(star, fleet);

            /* --- ➊ Telakan taso riittääkö top-alukseen? -------------------- */
            //Jos prio[0] on esim. 'Cruiser' ja telakka on lvl 2, tähti ohitetaan kokonaan –
            //se ei kuluta sotakukkarosta Fightereihin, vaan säästää kunnes:
                // telakka päivitetään lvl 3 tai
                // budjetti riittää jollakin toisella lvl 3-telakalla.
            if (prio.length) {                        // varmistus ettei ole tyhjä
                const topWanted   = prio[0];
                const neededLevel = SHIP_COST[topWanted][3];   // min shipyard lvl
                if (star.shipyardLevel < neededLevel) {
                    // console.log(`[AI ${this.aiId}] ${star.name}: yard lvl ${star.shipyardLevel} < `
                    //            + `${neededLevel}, skip (top prio ${topWanted})`);
                    continue;                          // seuraava tähti
                }
            }

            // console.log(
            //`%c[AI-${this.aiId}-ship-prio] ${star.name}  ` +
            // `F=${fleet.fighters} D=${fleet.destroyers} C=${fleet.cruisers}  ` +
            //`→ prio ${prio.join(' > ')}`,
            //'color:#fc6'
            // );

            for (const type of prio) {
            const [cC, cM, t, minLvl] = SHIP_COST[type];
            if (star.shipyardLevel < minLvl) continue;

            const cost = { credits: cC, minerals: cM };
            const expensive = EXPENSIVE_SHIP_TAGS.includes(type);

            if (expensive && !affordable(cost, warWallet)) {
                const closeEnough =
                    warWallet.credits  >= WAIT_THRESHOLD * cost.credits ||
                    warWallet.minerals >= WAIT_THRESHOLD * cost.minerals;
                if (closeEnough) {
                // console.log(`[AI ${this.aiId}] saving up for`, type);
                break; 
                }
            }
            if (!affordable(cost, warWallet)) continue;

            // *maksu sodan lompakosta*
            pay(cost, warWallet, this.res, walletName, this.aiId);

            window.pushToShipQueue(star, {
                type, timeLeft: t, totalTime: t, id: `ai_ship_${uuid()}`
            });
            // console.log(`AI ${this.aiId} Turn ${this.turn}: Queued ${type} at ${star.name}`);
            break;
            }
        }

        // console.log(`[AI-${this.aiId}-dbg] ships=${totalShips} mines=${totalMines}/${needMines} mustMine=${mustBuildMine}`);
        }


        // Analysoi nykyinen laivasto
        getFleetComposition(star) {
            const ships = this.allShips.filter(s => 
                s.owner === this.aiId && 
                (s.parentStar === star || s.targetStar === star)
            );
            
            return {
                fighters: ships.filter(s => s.type === 'Fighter').length,
                destroyers: ships.filter(s => s.type === 'Destroyer').length,
                cruisers: ships.filter(s => s.type === 'Cruiser').length,
                total: ships.length
            };
        }

        

        // Määritä mitä laivoja rakennetaan
        getShipBuildPriority(star, myFleet){

        /* --- alkuperäiset tavoitesuhteet -------------------------------- */
        const targetRatio = { Fighter:0.3, Destroyer:0.5, Cruiser:0.2 };

        /* --- kerää kaikkien pelaajien (human + other AIs) globaali tilanne --- */
        let totalEnemyDestroyers = 0;
        let totalEnemyTotal = 0;
        let anyEnemyHasPD = false;
        
        // Check all non-AI players for threats
        const enemies = [...new Set(this.allShips.map(s => s.owner))].filter(o => o !== this.aiId);
        enemies.forEach(enemyId => {
            const enemyFleet = getGlobalPlayerFleet(this.allShips, enemyId);
            totalEnemyDestroyers += enemyFleet.destroyers;
            totalEnemyTotal += enemyFleet.total;
            
            // Check if this enemy has any PD
            if (!anyEnemyHasPD) {
                anyEnemyHasPD = this.stars.some(s => s.owner === enemyId && s.defenseLevel > 0);
            }
        });
        
        const enemyHasManyDestroyers = totalEnemyTotal > 0 && (totalEnemyDestroyers / totalEnemyTotal) > 0.10;

        const prio = [];

        // 1) Cruiser boost jos a) enemies have many destroyers TAI b) PD
        if (star.shipyardLevel >= 3 && (enemyHasManyDestroyers || anyEnemyHasPD)) {
                prio.push('Cruiser');
        }

        // 2) Normaalit "täytä suhde" –säännöt
        if (star.shipyardLevel >= 3 &&
            (myFleet.total===0 || myFleet.cruisers/myFleet.total < targetRatio.Cruiser) &&
            !prio.includes('Cruiser')
        ){
            prio.push('Cruiser');
        }
        if (star.shipyardLevel >= 2 &&
            (myFleet.total===0 || myFleet.destroyers/myFleet.total < targetRatio.Destroyer)
        ){
            prio.push('Destroyer');
        }
        if (myFleet.total===0 || myFleet.fighters/myFleet.total < targetRatio.Fighter){
            prio.push('Fighter');
        }

        // 3) Täydennykset takaporttina, kuten aiemmin
        if (!prio.includes('Destroyer') && star.shipyardLevel >= 2) prio.push('Destroyer');
        if (!prio.includes('Fighter'))                              prio.push('Fighter');

        return prio;
        }

        /******************************************************************
         *  defendStars()
         *  – Kutsu lähistön vapaat alukset puolustamaan uhattuja planeettoja
         ******************************************************************/
        defendStars(){
            /* 1) Kaikki omat planeetat joilla on vihollisia kiertoradalla */
            const threatened = this.stars.filter(st =>
                st.owner === this.aiId &&
                st.orbitingShips?.some(sh => sh.owner !== this.aiId)
            );

            threatened.forEach(star=>{
                const hostile   = star.orbitingShips.filter(sh => sh.owner !== this.aiId);
                const friendly  = star.orbitingShips.filter(sh => sh.owner === this.aiId);

                let powerGap =
                    starThreatScore(star, hostile) -
                    friendly.reduce((sum,sh)=>sum + shipPower(sh), 0);

                if (powerGap <= 0) return;                    // jo turvassa

                /* 2) Vapaat omat alukset (state==='orbiting') muilta tähdiltä */
                const candidates = this.allShips.filter(sh =>
                    sh.owner === this.aiId &&
                    sh.state === 'orbiting' &&
                    sh.parentStar && sh.parentStar !== star
                ).sort((a,b)=>{
                    const pa = a.parentStar.mesh.position;
                    const pb = b.parentStar.mesh.position;
                    return pa.distanceTo(star.mesh.position) -
                        pb.distanceTo(star.mesh.position);
                });

                /* 3) Lähetä kunnes powerGap täyttyy (pieni yli-vara OK) */
                for (const sh of candidates){
                    powerGap -= shipPower(sh);

                    const srcStar = sh.parentStar;            // talteen ennen nollausta

                    sh.startStarId = srcStar.id;
                    sh.targetStar  = star;
                    sh.state       = 'moving';

                    const lane = srcStar.connections.includes(star.id);
                    sh.currentSpeed = lane ? SPEED_FAST : SPEED_SLOW;
                    if (sh.type==='Fighter' && !lane) sh.currentSpeed = FIGHTER_SPEED_SLOW;
                    sh.parentStar = null;

                    /* poista lähde-planeetan orbit-listalta */
                    if (srcStar.orbitingShips)
                        srcStar.orbitingShips = srcStar.orbitingShips.filter(s=>s!==sh);

                    if (powerGap <= 0) break;
                }
            });
        }


        /** Lähettää alukset valloittamaan */
        tryExpand(star){
            const ready = star.orbitingShips.filter(s=>s.owner===this.aiId && s.state==='orbiting');
            if(ready.length < 3) return; // Odota isompaa laivastoa
            
            const outbound = this.allShips.filter(s=>s.owner===this.aiId && s.startStarId===star.id && s.state==='moving');
            let target = outbound[0]?.targetStar || null;
            
            if(!target){
                const cands = this.stars.filter(s=>s.owner!==this.aiId && !s.isBeingConqueredBy);
                if(!cands.length) return;
                
                let best=-Infinity;
                cands.forEach(tg=>{
                    const lane = star.connections.includes(tg.id);
                    const dist = star.mesh.position.distanceTo(tg.mesh.position);
                    let sc = 1000 / (dist * (lane?1:NONLANE_FACTOR) + 25);
                    if(lane) sc += STARLANE_BONUS;
                    // Priority: neutrals > other AIs > player
                    if(tg.owner==='neutral') sc += 10;
                    else if(tg.owner !== PLAYER_ID) sc += 5; // Other AIs
                    else sc += 3; // Player
                    
                    if(sc > best){ best=sc; target=tg; }
                });
            }
            
            if(!target) return;
            
            /* --- ❷  VARMISTA, että laivasto selviää PD-ensilaukauksesta -------- */
            const pdLevels      = target.defenseLevel;
            const firstStrike   = pdLevels * 3;      // laukausten määrä
            const fightersReady = ready.filter(s => s.type === 'Fighter').length;

            /* jos kaikki Fighterit kuolisivat ennen kuin ampuvat, palaa myöhemmin */
            if (fightersReady > 0 && firstStrike >= ready.length) {
                // console.log(`[AI ${this.aiId}] Skip attack: ${target.name} PD first-strike ${firstStrike} > fleet ${ready.length}`);
                return;
            }

            const send = Math.min(ready.length, FLEET_TARGET);
            ready.slice(0, send).forEach(sh=>{
                sh.startStarId = star.id;
                sh.targetStar  = target;
                sh.state       = 'moving';
                const lane = star.connections.includes(target.id);
                sh.currentSpeed = lane ? SPEED_FAST : SPEED_SLOW;
                if(sh.type==='Fighter' && !lane) sh.currentSpeed = FIGHTER_SPEED_SLOW;
                sh.parentStar = null;
            });
            
            star.orbitingShips = star.orbitingShips.filter(s=>!(s.owner===this.aiId && s.state==='moving'));
        }

        /**  Erikois‑tilanne: AI:llä ei yhtään tukikohtaa  */
        recoverLostBase(){
            const home   = this.stars.find(s=>s.isHomeworld && s.owner!==this.aiId);
            const target = home || this.stars.find(s=>s.owner!==this.aiId) || null;
            if(!target) return;

            const fleet = this.allShips.filter(s=>s.owner===this.aiId && 
                (s.state==='orbiting'||s.state==='moving'||s.state==='conquering'));

            if(fleet.length){
                fleet.forEach(sh=>{
                    sh.startStarId = sh.parentStar?.id || sh.startStarId || null;
                    sh.targetStar  = target;
                    sh.state       = 'moving';
                    const start    = this.stars.find(st=>st.id===sh.startStarId);
                    const lane     = start ? start.connections.includes(target.id) : false;
                    sh.currentSpeed = lane ? SPEED_FAST : SPEED_SLOW;
                    if(sh.type==='Fighter' && !lane) sh.currentSpeed = FIGHTER_SPEED_SLOW;
                    sh.parentStar = null;
                });
                return;
            }

            if(target.owner==='neutral'){
                // console.warn(`[AI ${this.aiId}] Emergency‑claiming neutral star`,target.name);
                target.owner          = this.aiId;
                target.population     = 1;
                target.mines          = 0;
                target.shipyardLevel  = 0;
                target.defenseLevel   = 0;
                target.defenseHP      = 0;
                this.res.credits  = Math.max(0, this.res.credits  - 100);
                this.res.minerals = Math.max(0, this.res.minerals - 50);
            }
        }

        runTurn() {
            this.turn++;

            const myStars = this.stars.filter(s => s.owner === this.aiId);
            if (myStars.length === 0) {
                this.recoverLostBase();
                return;
            }
            
            const totalMines = myStars.reduce(
                (s,st)=>s+st.mines+queuedCount(st,'Mine'), 0);
            const totalShips = this.allShips.filter(s=>s.owner===this.aiId).length;

            // compute how much *new* money we got this turn
            const deltaCredits  = Math.max(0, this.res.credits  - this.prevRes.credits);
            const deltaMinerals = Math.max(0, this.res.minerals - this.prevRes.minerals);

            // split *just* that income
            const income = makeBudget3({credits: deltaCredits, minerals: deltaMinerals}, totalMines);

            // update prevRes so spending doesn't show up as "negative income" next time
            this.prevRes = {credits: this.res.credits, minerals: this.res.minerals};

            // stash it in the banks
            this.ecoBank.credits  += income.eco.credits;
            this.ecoBank.minerals += income.eco.minerals;
            this.techBank.credits  += income.tech.credits;
            this.techBank.minerals += income.tech.minerals;
            this.warBank.credits   += income.war.credits;
            this.warBank.minerals  += income.war.minerals;

            // zero out the bucket so we don't double-count
            income.eco.credits = income.eco.minerals =
            income.tech.credits = income.tech.minerals =
            income.war.credits = income.war.minerals = 0;

            // TÄHÄN lisäät budjetin, joka viittaa pankkeihisi:
            const budget = {
                eco : this.ecoBank,
                tech: this.techBank,
                war : this.warBank
            };

            // now your banks reflect starting cash + all "real" gains
            // console.log(
            // `[AI-${this.aiId}-wallets] ` +
            // `eco ${this.ecoBank.credits}/${this.ecoBank.minerals}  ` +
            // `tech ${this.techBank.credits}/${this.techBank.minerals}  ` +
            // `war ${this.warBank.credits}/${this.warBank.minerals}`
            // );

            // 2. Rakenna talous (yksi asia per kierros)
            const built = this.buildOneThingPerTurn(
                            myStars, totalMines, totalShips, budget);

            // 3. Laivat (rakennetaan samasta vuorosta)
            this.buildShipsSmartly(myStars,totalMines,totalShips,budget);

            // 3½.  Puolusta omia tähtiä ennen hyökkäyksiä
            this.defendStars();

            // 4. Lähetä laivoja
            myStars.forEach(star => this.tryExpand(star));
            
            // Debug: näytä kehitystilanne
            const developed = myStars.filter(s => s.shipyardLevel > 0 || s.infrastructureLevel > 1).length;
            // console.log(`AI ${this.aiId} developed stars: ${developed}/${myStars.length}`);
            }
        }

        /******************** 4)  Julkinen rajapinta pääpelille *******************/
        const AI_INSTANCES = new Map();
        
        window.initializeAI = (aiId, res, stars, ships) => {
            const instance = new AIController(aiId, res, stars, ships);

            // 1) seed prevRes for our delta-only logic
            instance.prevRes = {credits: res.credits, minerals: res.minerals};

            // 2) calculate initial budget based on starting resources
            const totalMines = stars
                .filter(s => s.owner === aiId)
                .reduce((sum, st) => sum + st.mines + queuedCount(st, 'Mine'), 0);
            const initial = makeBudget3(res, totalMines);

            // 3) stash it in the banks
            instance.ecoBank  = {...initial.eco};
            instance.techBank = {...initial.tech};
            instance.warBank  = {...initial.war};

            // console.log(
            //    `[AI-${aiId}-wallets startup] ` +
            //    `eco ${instance.ecoBank.credits}/${instance.ecoBank.minerals}  ` +
            //    `tech ${instance.techBank.credits}/${instance.techBank.minerals}  ` +
            //    `war ${instance.warBank.credits}/${instance.warBank.minerals}`
            //);
            
            AI_INSTANCES.set(aiId, instance);
        };
        
        window.runExternalEnemyAI = (aiId) => { 
            const instance = AI_INSTANCES.get(aiId);
            if (instance) instance.runTurn(); 
        };
        
        window.scoreBuild         = scoreBuild;
        window.makeBudget3         = makeBudget3;

        // Lisää globaalit apufunktiot pääpelille
        window.effectiveInfraLevel = effectiveInfraLevel;
        window.infraCost = infraCost;
        window.shipyardCost = shipyardCost;

        })();

        </script>
    <style>
        body { margin: 0; overflow: hidden; font-family: 'Inter', sans-serif; background-color: #000000; color: #e5e7eb; }
        
        #startScreen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background-color: rgba(17, 24, 39, 0.95); display: flex;
            flex-direction: column; 
            justify-content: center; 
            align-items: center; 
            z-index: 100;
            overflow-y: auto; 
            padding: 20px; 
        }
        #startScreenPanelsContainer {
            display: flex;
            flex-direction: row; 
            justify-content: center;
            align-items: flex-start; 
            gap: 20px; 
            flex-wrap: wrap; 
        }

        #uiContainer {
            position: absolute; top: 10px; left: 10px; 
            width: auto; 
            padding: 0; 
            display: none; 
            flex-direction: column; 
            align-items: flex-start; 
            pointer-events: none; 
            z-index: 5;
        }
        .infoPanel {
            background-color: rgba(31, 41, 55, 0.85); padding: 15px; border-radius: 8px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.2); color: #e5e7eb;
            pointer-events: auto; 
            min-width: 240px; 
            width: 240px; 
            margin-bottom: 10px; 
        }
        .infoPanel:last-child {
            margin-bottom: 0; 
        }
        .infoPanel h3 {
            font-size: 1.25rem; margin-bottom: 10px; color: #9ca3af;
            border-bottom: 1px solid #4b5563; padding-bottom: 8px;
        }
        .infoPanel label, .infoPanel span, .infoPanel li { display: block; margin-bottom: 6px; font-size: 0.875rem; }
        .infoPanel ul { list-style-type: disc; padding-left: 20px; }
        
        /* Button styling */
        .infoPanel select, .infoPanel button {
            position: relative; /* Needed for absolute positioning of progress bar */
            overflow: hidden; /* Hide overflowing progress bar */
            padding: 8px 12px; 
            border-radius: 6px; border: 1px solid #4b5563;
            background-color: #374151; color: #e5e7eb; margin-top: 6px; 
            cursor: pointer; transition: background-color 0.3s, box-shadow 0.3s;
            width: 100%; 
            box-sizing: border-box; font-size: 0.875rem;
            text-align: center; 
        }
        /* Span inside button for text, to keep it above progress bar */
        .infoPanel button span { 
            position: relative; 
            z-index: 2; 
            display: inline-block; /* Allow text centering */
            width: 100%;
            pointer-events: none; /* Allow clicks to pass through to the button */
        }

        .infoPanel button:not(#startGameButton):not(#resumeGameButton) { margin-top: 8px; }
        #startGameButton, #resumeGameButton { 
            background-color: #2563eb; font-weight: bold; margin-top: 10px; 
        }
        #resumeGameButton { background-color: #10b981; } 
        #startGameButton:hover, #resumeGameButton:hover { 
            background-color: #1d4ed8; 
        }
        #resumeGameButton:hover { background-color: #059669; }

        .infoPanel button:disabled { background-color: #4b5563; cursor: not-allowed; opacity: 0.7; }
        .infoPanel select:hover, .infoPanel button:not(:disabled):hover { background-color: #4b5563; }
        .infoPanel select:focus, .infoPanel button:focus { outline: none; box-shadow: 0 0 0 3px #60a5fa; }

        /* Progress bar inside button */
        .button-progress-bar {
            position: absolute;
            bottom: 0;
            left: 0;
            height: 100%; /* Fill height */
            top: 0; /* Align to top */
            background-color: rgba(96, 165, 250, 0.4); /* Default blue progress color with opacity */
            width: 0%; /* Initial width */
            transition: width 0.1s linear;
            z-index: 1; /* Below text */
            border-radius: 0; /* No radius needed if filling */
            pointer-events: none;      /* progress‑overlay ei nappaa klikkausta */
        }
        /* Specific colors for different queues (with opacity) */
        #progress-Infrastructure { background-color: rgba(139, 92, 246, 0.4); } /* Violet */
        #progress-Shipyard, #progress-UpgradeShipyard { background-color: rgba(245, 158, 11, 0.4); } /* Amber */
        #progress-Mine { background-color: rgba(160, 166, 179, 0.5); } /* Gray */
        #progress-Defense { background-color: rgba(239, 68, 68, 0.4); } /* Red */
        #progress-Fighter, #progress-Destroyer, #progress-Cruiser { background-color: rgba(59, 130, 246, 0.4); } /* Blue */

        /* AI player settings */
        .ai-player-config {
            margin-top: 10px;
            padding: 10px;
            border: 1px solid #4b5563;
            border-radius: 6px;
            background-color: rgba(55, 65, 81, 0.5);
        }
        .ai-player-config label {
            font-size: 0.875rem;
            color: #d1d5db;
            margin-bottom: 4px;
        }
        .ai-color-picker {
            width: 100%;
            height: 40px;
            border: 1px solid #4b5563;
            border-radius: 4px;
            cursor: pointer;
            margin-top: 4px;
        }

        #planetMenu { display: none; }
        #selectedUnitsPanel { 
            position: absolute;
            bottom: 10px;
            left: 10px;
            background-color: rgba(31, 41, 55, 0.85);
            padding: 8px 12px;
            border-radius: 8px;
            color: #e5e7eb;
            font-size: 0.875rem;
            z-index: 6; 
            display: none; 
        }


        #gameCanvas { display: block; width: 100vw; height: 100vh; position: fixed; top:0; left:0; z-index: 1; cursor: default;}
        #selectionBox {
            position: absolute; border: 1px dashed #888888; /* Grey border */
            background-color: rgba(136, 136, 136, 0.1); /* Grey background */
            pointer-events: none; 
            display: none; z-index: 99;
        }
        /* Keep general progress bar styles for reference or other uses */
        .progressBarContainer {
            width: 100%; background-color: #4b5563; 
            border-radius: 0.25rem; height: 1.1rem; 
            margin-top: 0.25rem; 
            overflow: hidden; position: relative; 
        }
        .progressBarFill { 
            background-color: #3b82f6; 
            height: 100%;
            position: absolute; top: 0; left: 0;
            transition: width 0.1s linear; 
            pointer-events:none; 
        }
        #planetaryConstructionProgressBarFill { 
            background-color: #6d28d9; 
        }
        #populationProgressBarFill {
            background-color: #10b981; 
        }
        #conquestProgressBarFill {
             background-color: #f59e0b; 
        }
        .progressBarText { 
            position: absolute; width: 100%; height: 100%;
            top: 0; left: 0; display: flex;
            align-items: center; justify-content: center;
            color: white; font-size: 0.7rem; 
            line-height: 1.1rem; text-align: center; z-index: 1; 
        }
        .progressLabel { 
            font-size: 0.75rem; color: #9ca3af; 
            margin-top: 0.25rem; display: block;
        }
        .queueTitle { 
            font-size: 0.8rem;
            color: #d1d5db; 
            margin-top: 10px;
            margin-bottom: 2px;
            font-weight: 500;
        }
        .queueInfo { 
            font-size: 0.75rem;
            color: #9ca3af;
            margin-bottom: 4px;
        }
        /* Added margin for better spacing in planet menu */
        #planetMenu > span.mt-3 { /* More specific selector for spacing */
             margin-top: 0.75rem !important; 
        }
         #planetMenu > button { 
             margin-top: 0.25rem; 
        }
         #planetMenu > .queueTitle {
             margin-top: 1.25rem; 
         }

        /*planetary queuen idle-tekstin väri harmaaksi */
        #planetaryQueueTotalProgressText[idle],
        #shipQueueTotalProgressText[idle] { color:#9ca3af; }

        /* ———  GAME-SPEED-PANEELI  ——————————————————————————————— */
        #speedPanel{
        position: fixed;
        top: 0.5rem;          /* top-2  (≈ 8 px)  */
        right: 0.75rem;       /* right-3 (≈ 12 px) */
        z-index: 50;          /* z-50   */
        display: flex;        /* flex   */
        gap: 0.25rem;         /* gap-1  */
        pointer-events: auto; /* jotta nappulat saa klikattua */
        }

        #speedPanel button{
        background: #374151;      /* bg-gray-700 */
        color: #e5e7eb;           /* text-gray-200 */
        padding: 0.25rem 0.5rem;  /* py-1 px-2   */
        font-size: 0.875rem;      /* text-sm     */
        border: 1px solid #4b5563;
        border-radius: 0.375rem;  /* rounded-md  */
        cursor: pointer;
        transition: background-color .15s ease;
        }

        #speedPanel button:hover:not(.active){
        background: #4b5563;      /* hover-tausta hieman vaaleampi */
        }

        #speedPanel button.active{
        background: #2563eb;      /* bg-blue-600 */
        font-weight: 700;         /* font-bold   */
        }

        #speedPanel button:focus{
        outline: none;
        box-shadow: 0 0 0 3px rgba(96,165,250,.6); /* sama kuin Tailwind focus-rengas */
        }

        .groups-panel{
        position:fixed;       /* kelluu ruudulla */
        bottom:20px; left:50%;
        transform:translateX(-50%);
        display:flex; flex-direction:column; align-items:center;
        pointer-events:auto; z-index:6;
        }
        .groups-title{font-size:.8rem;color:#9ca3af;margin-bottom:4px;letter-spacing:.05em;text-transform:uppercase;}
        .groups-buttons{display:flex;gap:4px;flex-wrap:wrap;justify-content:center;margin-bottom: 8px;}
        .group-btn{
        min-width:78px;            /* vähän leveämpi että teksti mahtuu */
        padding:4px 8px;
        border-radius:6px;
        background:#374151;        /* sama harmaa kuin muissa napeissa */
        border:1px solid #4b5563;
        color:#e5e7eb;
        font-size:.70rem;          /* hieman pienempi fontti */
        line-height:1.1rem;
        text-align:left;           /* rivit allekkain vasuriin */
        cursor:pointer;
        transition:background-color .15s ease, transform .15s ease;
        }
        .group-btn:hover{
        background:#4b5563;        /* vaaleampi hover-tausta */
        transform:translateY(-1px);/* kevyt liike ylös */
        }
        .group-btn:active{
        transform:translateY(0);   /* paina takaisin alas */
        }

        #custom-tooltip {
        position: absolute;
        background-color: rgba(17, 24, 39, 0.95); /* Tumma, UI:hin sopiva tausta */
        color: #e5e7eb;
        padding: 8px 12px;
        border-radius: 6px;
        border: 1px solid #4b5563;
        font-size: 14px; /* Suurempi fonttikoko */
        z-index: 101;    /* Varmistaa, että on kaiken päällä */
        pointer-events: none; /* Ei häiritse hiiren klikkauksia */
        white-space: nowrap;
        transition: opacity 0.1s ease;
        opacity: 0;
        }

        #custom-tooltip.visible {
            opacity: 1;
        }

    </style>
</head>
<body>
    <div id="startScreen">
        <div id="startScreenPanelsContainer">
            <!-- Legend panel on the left -->
            <div id="legendPanel" class="infoPanel">
                <h3>Game Legend</h3>

                <h4 class="mt-2 font-medium text-sm text-gray-400">SHIPS</h4>
                <ul class="list-disc pl-5 text-xs">
                <li>
                    <strong>Fighter</strong> (1 dmg, 1 HP) – 
                    <em>Strong vs. Cruisers, weak vs. Destroyers, minimal PD damage (0.25)</em>
                        Requires: <em>Shipyard lvl 1</em>
                    
                </li>
                <li>
                    <strong>Destroyer</strong> (2 × 1 dmg, 2 HP) –  
                    <em>First-Strike vs. Fighters, weak vs. Cruisers, low PD damage (0.5)</em>
                        Requires: <em>Shipyard lvl 2</em>
                    
                </li>
                <li>
                    <strong>Cruiser</strong> (3 dmg, 3 HP) –   
                    <em>First-Strike vs. Destroyers & PD, weak vs. Fighters, fastest conquest</em>
                        Requires: <em>Shipyard lvl 3</em>
                    
                </li>
                </ul>

                <h4 class="mt-3 font-medium text-sm text-gray-400">PLANETARY DEVELOPMENT</h4>
                <ul class="list-disc pl-5 text-xs">
                <li>
                    <strong>Population</strong> – +1 credit / 10 s per pop
                </li>
                <li>
                    <strong>Minerals</strong> – +1 mineral / 10 s per mine
                </li>
                </ul>

                <h4 class="mt-3 font-medium text-sm text-gray-400">BUILDINGS</h4>
                <ul class="list-disc pl-5 text-xs">
                <li>
                    <strong>Mine</strong> – +1 mine (+1 mineral / 10 s)
                </li>
                <li>
                    <strong>Planetary Defense</strong> – 3 × First-Strike, 2 dmg/shot, 2 HP
                </li>
                </ul>

                <h4 class="mt-3 font-medium text-sm text-gray-400">UPGRADES</h4>
                <ul class="list-disc pl-5 text-xs">
                <li>
                    <strong>Infrastructure (lvl 1–6)</strong>  
                    <em>Unlocks Shipyard upgrades, +5 population cap, +5 mine cap, +1–2 PD cap</em>
                </li>
                <li>
                    <strong>Shipyard (lvl 1–3)</strong>  
                    <em>lvl 2 → Destroyers; lvl 3 → Cruisers</em>
                </li>
                </ul>
            </div>
            <div id="gameSetupPanel" class="infoPanel">
                <h3>Game Settings</h3>
                <label for="starCount">Number of Stars:</label>
                <select id="starCount">
                    <option value="75">75 Stars - EASY</option><option value="150" selected >150 Stars - NORMAL</option>
                    <option value="250">250 Stars - HARD</option><option value="500">500 Stars - VERY HARD</option>
                </select>
                <label for="numAiPlayers" class="block mt-3">Number of AI Opponents (1-4):</label>
                    <select id="numAiPlayers" class="mt-1 block w-full py-2 px-3 border border-gray-600 bg-gray-700 text-white rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm">
                        <option value="1" selected>1</option>
                        <option value="2">2</option>
                        <option value="3">3</option>
                        <option value="4">4</option>
                    </select>
                    <div id="aiPlayerSettingsContainer" class="mt-3">
                </div>
                <button id="startGameButton"><span>Start Game</span></button>
                <button id="resumeGameButton" style="display: none;"><span>Resume Game</span></button>
            </div>
                <div id="controlsGuidePanel" class="infoPanel">
                <h3>Controls Guide</h3>

                <!-- GAME -------------------------------------------------------->
                <h4 class="mt-2 font-medium text-sm text-gray-400">GAME</h4>
                <ul class="list-disc pl-5 text-xs">
                    <li><strong>ESC:</strong> <em>Pause / Show This Menu</em></li>
                </ul>

                <!-- CAMERA ------------------------------------------------------>
                <h4 class="mt-3 font-medium text-sm text-gray-400">CAMERA</h4>
                <ul class="list-disc pl-5 text-xs">
                    <li><strong>LMB + Drag:</strong><em> Rotate View</em></li>
                    <li><strong>RMB + Drag:</strong> <em>Pan View</em></li>
                    <li><strong>Mouse Wheel:</strong> <em>Zoom In/Out</em></li>
                    <li><strong>Double-Click Star:</strong> <em>Center on Star</em></li>
                </ul>

                <!-- SELECTION --------------------------------------------------->
                <h4 class="mt-3 font-medium text-sm text-gray-400">SELECTION</h4>
                <ul class="list-disc pl-5 text-xs">
                    <li><strong>LMB Click Ship:</strong> <em>Select Ship</em></li>
                    <li><strong>SHIFT + LMB Click:</strong><em> Add/Remove</em></li>
                    <li><strong>SHIFT + LMB Drag:</strong> <em>Area Select</em></li>
                </ul>

                <!-- COMMANDS ----------------------------------------------------->
                <h4 class="mt-3 font-medium text-sm text-gray-400">COMMANDS</h4>
                <ul class="list-disc pl-5 text-xs">
                    <li><strong>RMB Click Star (ships selected):</strong> <em>Move</em></li>
                </ul>

                <!-- GROUPS ------------------------------------------------------->
                <h4 class="mt-3 font-medium text-sm text-gray-400">GROUPS</h4>
                <ul class="list-disc pl-5 text-xs">
                    <li><strong>CTRL + [0-9]:</strong><em> Assign Group</em></li>
                    <li><strong>[0-9]:</strong> <em>Select Group</em></li>
                    <li><strong>[0-9] (double-press):</strong> <em>Focus camera on group</em></li>
                    <li><strong>Click Group Button (in Fleets panel):</strong> <em>Focus camera on group</em></li>
                </ul>
                </div>
        </div>
    </div>

    <div id="uiContainer">
        <div id="resourcePanel" class="infoPanel">
            <h3>Resources</h3>
            <span id="creditsDisplay">Credits: 0</span>
            <span id="mineralsDisplay">Minerals: 0</span>
        </div>
        <div id="planetMenu" class="infoPanel">
            <h3 id="planetMenuTitle">Selected Star Menu</h3>
            <span id="planetOwner">Owner: -</span>
            <span id="planetPopulation">Population: 0 / 0</span>
            <div id="populationProgressContainer" class="progressBarContainer" style="display: none;">
                <div id="populationProgressBarFill" class="progressBarFill" style="width: 0%;"></div>
                <span id="populationProgressBarText" class="progressBarText">0%</span>
            </div>
            <div class="queueTitle mt-5">Planetary Queue</div>
            <span id="planetaryQueueInfo" class="queueInfo">Queue: 0</span>
            <div id="planetaryQueueTotalProgressContainer"
                class="progressBarContainer"
                style="margin-top:4px;">
            <div id="planetaryQueueTotalProgressFill"
                class="progressBarFill"
                style="width:0%; background-color:rgba(139,92,246,0.6)"></div>
            <span id="planetaryQueueTotalProgressText"
                    class="progressBarText">0%</span>
            </div>
            <div id="planetaryConstructionProgressContainer" style="display: none; margin-top: 5px;"> 
                <span id="planetaryConstructingItemType" class="progressLabel"></span>
            </div>
            <span id="planetInfraLevel" class="mt-3">Infrastructure Level: 1</span>
            <button id="upgradeInfrastructureButton" data-cost-credits="200" data-cost-minerals="150" data-build-time="30">
                <span>Upgrade Infrastructure</span>
                <div class="button-progress-bar" id="progress-Infrastructure"></div> 
            </button> 
            <span id="planetMines" class="mt-3">Mines: 0 / 0</span>
             <button id="buildMineButton" data-cost-credits="75" data-cost-minerals="25" data-build-time="10">
                <span>Build Mine (75C, 25M)</span>
                 <div class="button-progress-bar" id="progress-Mine"></div>
            </button>
            <span id="planetDefense" class="mt-3">Defense: 0 / 0</span> 
             <button id="buildDefenseButton" data-cost-credits="100" data-cost-minerals="50" data-build-time="15">
                <span>Upgrade Defense (100C, 50M)</span>
                 <div class="button-progress-bar" id="progress-Defense"></div>
            </button>
            <span id="planetShipyardLevel" class="mt-3">Shipyard Level: 0</span>
             <button id="buildShipyardButton" data-cost-credits="150" data-cost-minerals="100" data-build-time="20">
                <span>Build Shipyard (150C, 100M)</span>
                 <div class="button-progress-bar" id="progress-Shipyard"></div>
            </button>
            <button id="upgradeShipyardButton" data-cost-credits="250" data-cost-minerals="200" data-build-time="40">
                <span>Upgrade Shipyard</span>
                 <div class="button-progress-bar" id="progress-UpgradeShipyard"></div>
            </button> 

            <div class="queueTitle mt-5">Ship Queue</div>
            <span id="shipQueueInfo" class="queueInfo">Queue: 0</span>
            <div id="shipQueueTotalProgressContainer"
                class="progressBarContainer"
                style="margin-top:4px;">
            <div id="shipQueueTotalProgressFill"
                class="progressBarFill"
                style="width:0%; background-color:rgba(59,130,246,0.6)"></div>
            <span id="shipQueueTotalProgressText"
                    class="progressBarText">0%</span>
            </div>
             <button id="buildFighterButton" data-type="Fighter">
                <span>Build Fighter</span>
                <div class="button-progress-bar" id="progress-Fighter"></div>
            </button>
            <button id="buildDestroyerButton" data-type="Destroyer">
                <span>Build Destroyer</span>
                 <div class="button-progress-bar" id="progress-Destroyer"></div>
            </button> 
            <button id="buildCruiserButton" data-type="Cruiser">
                <span>Build Cruiser</span>
                 <div class="button-progress-bar" id="progress-Cruiser"></div>
            </button> 
            <button id="buildSlipstreamFrigateButton" data-type="Slipstream Frigate">
                <span>Build Slipstream Frigate</span>
                <div class="button-progress-bar" id="progress-SlipstreamFrigate"></div>
            </button>
            <div id="shipConstructionProgressContainer" style="display: none; margin-top: 5px;">
                <span id="shipConstructingItemType" class="progressLabel"></span>
            </div>
            
            <div id="conquestProgressContainer" class="progressBarContainer" style="display: none; margin-top: 15px;">
                <div id="conquestProgressBarFill" class="progressBarFill" style="width: 0%;"></div>
                <span id="conquestProgressBarText" class="progressBarText">0%</span>
            </div>
            <span id="conqueringStatusText" class="progressLabel" style="display: none;"></span>
        </div>
    </div>

    <!---- GAME-SPEED PANEL -->
    <div id="speedPanel" class="fixed top-2 right-3 z-50 flex gap-1 pointer-events-auto">
        <button data-speed="pause">⏸</button>
        <button data-speed="1">1×</button>
        <button data-speed="2">2×</button>
        <button data-speed="5">5×</button>
        <button data-speed="10">10×</button>
    </div>

    <div id="selectedUnitsPanel">Selected Units: 0</div>
    <div id="selectionBox"></div>
    <canvas id="gameCanvas"></canvas>

    <!-- ==== CONTROL GROUP PANEL ==== -->
    <div id="groupsPanel" class="groups-panel" style="display:none;">
        <span class="groups-title">Fleets </span>
        <div id="groupsButtonsContainer" class="groups-buttons"></div>
        <span></span>
        <span class="groups-title">Focus Camera: Click button or double-press number </span>
        <span></span>
    </div>

    <script type="importmap">
        { "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.164.1/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.164.1/examples/jsm/"
        }}
        
    </script>
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { EffectComposer }        from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass }            from 'three/addons/postprocessing/RenderPass.js';
        import { BokehPass }             from 'three/addons/postprocessing/BokehPass.js'; 
        // TWEEN is globally available

        // Audio Variables
        let audioContextStarted = false;
        let masterVolume;
        let synthButtonClick;
        let synthButtonHoverEffect; 
        let ambientHum, ambientFilter, ambientPanner;
        let lastButtonClickTime = 0;
        let lastButtonHoverTime = 0; 
        const BUTTON_CLICK_COOLDOWN = 0.05; 
        const BUTTON_HOVER_COOLDOWN = 0.03; 

        let scene, camera, renderer, controls, composer;
        let bokeh; 
        let bokehFocusTarget = null;

        let stars = [];
        let allShips = []; 
        let starConnections = []; // Stores Line objects
        let starGlows = []; 
        let nebulaSprites = []; 
        // ---- Nebula-säädöt -------------------------------------------
        const NEBULA_SPRITE_COUNT       = 300;   // pieniä spritejä
        const NEBULA_BIG_COUNT          = 160;     // jättisumuja
        const NEBULA_SMALL_SIZE_RANGE   = [ 700, 980 ];   // pienien skaala (Three-yksikköä)
        const NEBULA_BIG_SIZE_RANGE     = [ 2500, 2000 ];  // isojen skaala
        const NEBULA_OPACITY_SMALL      = 0.86;  // hentouden määrä
        const NEBULA_OPACITY_BIG        = 0.55;  // vielä haaleampi
        const NEBULA_TINTS = [ 0x4477ff, 0x7755dd, 0x8844bb, 0xaa3377, 0x9944cc, 0x0094cc ];
        let backgroundStars; 


        let selectedStar = null;
        let hoveredStar = null; 
        let selectedShips = [];
        let controlGroups = {}; 
        let gameState = 'initialStartScreen'; 
        let gameInProgress = false; 
        let areaAdditive = false;   // true = lisää valintaan, false = korvaa
        let selectionIndicatorMesh = null;

        const clock = new THREE.Clock();

        let resourceInterval = 10; 
        let populationInterval = 10; 
        let timeSinceLastResourceTick = 0;
        let timeSinceLastPopulationTick = 0;
        let aiDecisionInterval = 5; 
        let timeSinceLastAIDecision = 0;


        let isAreaSelecting = false;
        let areaSelectionStartPoint = new THREE.Vector2();
        const selectionBoxElement = document.getElementById('selectionBox');
        const selectedUnitsPanel = document.getElementById('selectedUnitsPanel'); 

        let playerResources = { credits: 1000, minerals: 500 };
        let aiResources = new Map(); // Store resources for each AI
        let aiPlayers = []; // Store AI player configurations
        let aiPhase = 'EXPAND';
        
        const PLAYER_ID = 'player'; 
        const PLAYER_COLOR = 0x68c5ff; 
        const NEUTRAL_COLOR = 0xffffff;
        const SHIP_COLOR_PLAYER = 0x9ed6f9; 
        const SELECTED_SHIP_COLOR = 0x00ff00; 
        
        const SHIP_SPEED_FAST = 60; 
        const SHIP_SPEED_SLOW = 6;
        const FIGHTER_SPEED_SLOW = SHIP_SPEED_SLOW * 2;  
        const CONQUEST_RATE_PER_SHIP = 1; 
        const AI_ATTACK_FLEET_SIZE = 3; 
        const COMBAT_CHECK_INTERVAL = 0.5; 
        let timeSinceLastCombatCheck = 0;
        const DEFENSE_STRENGTH_MULTIPLIER = 4; // Planetary defense destroys this many ships per level


        const STAR_CONNECTION_MAX_DIST_BASE = 175;
        const STAR_CONNECTION_PROBABILITY = 0.25; 
        const MIN_HOMEWORLD_DISTANCE_FACTOR = 0.4; 

        const INDICATOR_BASE_COLOR = 0x6495ED;   // CornflowerBlue – erottuu hyvin

        /*  DEBUG: pelin nopeuskerroin  —  1 = normaali   10 = kymmenkertainen  */
        let GAME_SPEED = 1;      // 1×, 2×, 5×, 10× …
        let isPaused   = false;
        
        // Initialize with a sample of colors (these will be overridden by user selection)
        const DEFAULT_AI_COLORS = [
            0xdc3545, // Red
            0x28a745, // Green  
            0xffc107, // Yellow
            0x6f42c1  // Purple
        ];

        /*  --------  BUILD SHIP BUTTON SYNC  --------  */
        function syncShipButtons() {
        ['Fighter', 'Destroyer', 'Cruiser', 'Slipstream Frigate'].forEach(type => {
            const [c, m, t] = SHIP_COST[type];         // [credits, minerals, time]
            const btn = document.querySelector(`#build${type}Button`);
            if (!btn) return;                          // turvallisuus

            btn.dataset.costCredits  = c;
            btn.dataset.costMinerals = m;
            btn.dataset.buildTime    = t;

            // Päivitä myös nappiteksti, jotta pelaaja näkee hinnan oikein
            const label = btn.querySelector('span');
            if (label) label.textContent = `Build ${type} (${c}C, ${m}M)`;
        });
        }


        // Infrastructure Level Limits
        const INFRA_LIMITS = {
            1: { maxPop: 5, maxMines: 5, maxDefense: 1, maxShipyard: 1 },
            2: { maxPop: 10, maxMines: 10, maxDefense: 2, maxShipyard: 2 },
            3: { maxPop: 15, maxMines: 15, maxDefense: 4, maxShipyard: 3 },
            4: { maxPop: 20, maxMines: 20, maxDefense: 6, maxShipyard: 4 }, 
            5: { maxPop: 25, maxMines: 25, maxDefense: 8, maxShipyard: 4 }  // Placeholder for future
        };
        window.INFRA_LIMITS = INFRA_LIMITS; 

        /* ----------  PLANETARY COST HELPERS  ---------- */
        /*  Voit säätää kertoimia tai tehdä taulukoita, jos haluat tarkan portaittaisen hinnoittelun. */

        //Infra maksaa saman verran kuin shipyard
        function infraCost(currentLevel){
            return shipyardCost(currentLevel);   
        }

        function shipyardCost(currentLevel) {       // 0 = ei telakkaa vielä
        if (currentLevel === 0) {                 // telakan rakentaminen
            return { nextLevel: 1, credits:150, minerals:100, time:20 };
        }
        const base = { c: 150, m: 100, t: 40 };
        const factor = 1 + 0.3 * (currentLevel-1);/* 1.0, 1.3, 1.6 ... */
        return {
            nextLevel : currentLevel + 1,
            credits   : Math.round(base.c * factor),
            minerals  : Math.round(base.m * factor),
            time      : Math.round(base.t * factor)
        };
        }
        
        const INDICATOR_SPRITE_SCALE = 2.8; 

        /* ----------  STAR NAME GENERATOR  ---------- */
        function generateStarName() {
            const letters   = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
            const prefix    = [...Array(3)]
                                .map(() => letters[Math.floor(Math.random()*letters.length)])
                                .join('');
            const numbers   = String(Math.floor(Math.random()*10_000)).padStart(4,'0');
            return `${prefix}-${numbers}`;          // esim. JFK‑0057
            }

        // Visual Feedback Constants
        const STAR_GLOW_DEFAULT_OPACITY = 0.6;
        const STAR_GLOW_HOVER_OPACITY = 0.9;
        const STAR_GLOW_SELECTED_OPACITY = 1.0;
        const STAR_GLOW_DEFAULT_SCALE = 6.0; 
        const STAR_GLOW_HOVER_SCALE_FACTOR = 1.25;
        const STAR_GLOW_SELECTED_SCALE_FACTOR = 1.50; 
        const STAR_LANE_DEFAULT_OPACITY = 0.3;
        const STAR_LANE_HOVER_OPACITY = 0.7;
        const STAR_LANE_SELECTED_OPACITY = 1.0;
        const CONNECTED_STAR_HOVER_GLOW_OPACITY = 0.9;
        const CONNECTED_STAR_SELECTED_GLOW_OPACITY = 0.85;

        /*  ——  EFFECTS  ——  */
        const explosions = [];   // {points, velocities:Vector3[], life, ttl}


        // DOM Elements
        const startScreenDiv = document.getElementById('startScreen');
        const startGameButton = document.getElementById('startGameButton');
        const resumeGameButton = document.getElementById('resumeGameButton'); 
        const starCountSelect = document.getElementById('starCount');
        const numAiPlayersSelect = document.getElementById('numAiPlayers');
        const aiPlayerSettingsContainer = document.getElementById('aiPlayerSettingsContainer');
        const uiContainerDiv = document.getElementById('uiContainer');
        const resourcePanelDiv = document.getElementById('resourcePanel');
        const creditsDisplay = document.getElementById('creditsDisplay');
        const mineralsDisplay = document.getElementById('mineralsDisplay');
        const planetMenuDiv = document.getElementById('planetMenu');
        const planetMenuTitle = document.getElementById('planetMenuTitle');
        const planetOwnerDisplay = document.getElementById('planetOwner');
        const planetInfraLevelDisplay = document.getElementById('planetInfraLevel'); 
        const planetDefenseDisplay = document.getElementById('planetDefense');
        const planetPopulationDisplay = document.getElementById('planetPopulation');
        const populationProgressContainer = document.getElementById('populationProgressContainer');
        const populationProgressBarFill = document.getElementById('populationProgressBarFill');
        const populationProgressBarText = document.getElementById('populationProgressBarText');
        const planetMinesDisplay = document.getElementById('planetMines');
        const planetShipyardLevelDisplay = document.getElementById('planetShipyardLevel'); 

        const upgradeInfrastructureButton = document.getElementById('upgradeInfrastructureButton'); 
        const buildShipyardButton = document.getElementById('buildShipyardButton');
        const upgradeShipyardButton = document.getElementById('upgradeShipyardButton'); 
        const buildMineButton = document.getElementById('buildMineButton');
        const buildDefenseButton = document.getElementById('buildDefenseButton');
        const buildFighterButton = document.getElementById('buildFighterButton'); 
        const buildDestroyerButton = document.getElementById('buildDestroyerButton'); 
        const buildCruiserButton = document.getElementById('buildCruiserButton'); 
        const buildSlipstreamFrigateButton = document.getElementById('buildSlipstreamFrigateButton');

        
        const planetaryQueueInfo = document.getElementById('planetaryQueueInfo');
        const planetaryConstructionProgressContainer = document.getElementById('planetaryConstructionProgressContainer');
        const planetaryConstructingItemTypeSpan = document.getElementById('planetaryConstructingItemType');
        const planetaryQueueTotalProgressFill = document.getElementById('planetaryQueueTotalProgressFill'); 
        const planetaryQueueTotalProgressText = document.getElementById('planetaryQueueTotalProgressText'); 

        const shipQueueInfo = document.getElementById('shipQueueInfo');
        const shipConstructionProgressContainer = document.getElementById('shipConstructionProgressContainer');
        const shipConstructingItemTypeSpan = document.getElementById('shipConstructingItemType');
        const shipQueueTotalProgressFill = document.getElementById('shipQueueTotalProgressFill'); 
        const shipQueueTotalProgressText = document.getElementById('shipQueueTotalProgressText'); 
        
        const conquestProgressContainer = document.getElementById('conquestProgressContainer');
        const conquestProgressBarFill = document.getElementById('conquestProgressBarFill');
        const conquestProgressBarText = document.getElementById('conquestProgressBarText');
        const conqueringStatusText = document.getElementById('conqueringStatusText');

        /*  ---- combat constants ---- */
        const DEFENSE_HP_PER_LEVEL       = 4;      // PD:n "hit-pointit" / taso
        const CRUISER_DMG_VS_DEFENSE     = 4;      // entinen arvo
        const DESTROYER_DMG_VS_DEFENSE   = 0.5;    // uusi - ½ HP / laukaus
        const FIGHTER_DMG_VS_DEFENSE     = 0.25;   // uusi - ¼ HP / laukaus

        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2(); 
        const currentMousePosition = new THREE.Vector2(); 
        let lastClickTime = 0; 
        const DOUBLE_CLICK_THRESHOLD = 300; 

        // Kamerafocus groupiin groupin numeron tuplanäpäytyksellä -pohjustus
        let lastGroupKey   = null;
        let lastGroupKeyAt = 0;

        let mouseDownPosition = null; // Tallentaa hiiren sijainnin, kun nappi painetaan
        const CLICK_DRAG_THRESHOLD = 5; // Kuinka monta pikseliä hiiri saa liikkua, että se on vielä klikkaus
        const SELECTION_INDICATOR_ROTATION_SPEED = 0.5; // Radiaania sekunnissa, säädä mieleiseksesi


        // --- Indicator Textures & Materials (created once) ---
        function createSquareTexture(color) {
            const canvas = document.createElement('canvas');
            canvas.width = 32; 
            canvas.height = 32;
            const context = canvas.getContext('2d');
            context.fillStyle = new THREE.Color(color).getStyle();
            context.fillRect(0, 0, 32, 32);
            return new THREE.CanvasTexture(canvas);
        }

        function createCircleTexture(color) {
            const canvas = document.createElement('canvas');
            canvas.width = 32;
            canvas.height = 32;
            const context = canvas.getContext('2d');
            context.beginPath();
            context.arc(16, 16, 15, 0, 2 * Math.PI, false); 
            context.fillStyle = new THREE.Color(color).getStyle();
            context.fill();
            return new THREE.CanvasTexture(canvas);
        }
        
        function createOctagonTexture(color) {
            const canvas = document.createElement('canvas');
            canvas.width = 64;
            canvas.height = 64;
            const ctx = canvas.getContext('2d');
            const numberOfSides = 8;
            const size = 32; // Radius of the octagon
            const Xcenter = 32;
            const Ycenter = 32;
            ctx.beginPath();
            ctx.moveTo (Xcenter +  size * Math.cos(0), Ycenter +  size * Math.sin(0));          
            for (var i = 1; i <= numberOfSides;i += 1) {
                ctx.lineTo (Xcenter + size * Math.cos(i * 2 * Math.PI / numberOfSides), Ycenter + size * Math.sin(i * 2 * Math.PI / numberOfSides));
            }
            ctx.fillStyle = new THREE.Color(color).getStyle();
            ctx.fill();
            return new THREE.CanvasTexture(canvas);
        }

        // ----------- RÄJÄHDYS KUN ALUS TUHOUTUU -------------------
        function createSparkTexture() {         // 32 × 32 px "kipinä"
            const c = document.createElement('canvas');
            c.width = c.height = 32;
            const ctx = c.getContext('2d');
            const g = ctx.createRadialGradient(16,16,0, 16,16,16);
            g.addColorStop(0,  'rgba(255,255,255,1)');
            g.addColorStop(0.3,'rgba(255,200,80,1)');
            g.addColorStop(1,  'rgba(255,200,80,0)');
            ctx.fillStyle = g; ctx.fillRect(0,0,32,32);
            const tex = new THREE.CanvasTexture(c);
            tex.encoding = THREE.sRGBEncoding;
            return tex;
            }
            const SPARK_TEX = createSparkTexture();
            const SPARK_MAT = new THREE.PointsMaterial({
            map: SPARK_TEX, size: 3, transparent:true,
            blending: THREE.AdditiveBlending, depthWrite:false
            });

        function spawnExplosion(pos, n=18) {
            // satunnaiset suuntavektorit
            const positions = new Float32Array(n*3);
            const velocities = [];
            for (let i=0; i<n; i++){
                const v = new THREE.Vector3(
                (Math.random()-0.5),
                (Math.random()-0.5),
                (Math.random()-0.5)
                ).normalize().multiplyScalar(20);   // lähtönopeus
                velocities.push(v);
                positions.set([0,0,0], i*3);        // piste keskelle, siirretään myöhemmin
            }

            const geom = new THREE.BufferGeometry();
            geom.setAttribute('position', new THREE.BufferAttribute(positions,3));
            const points = new THREE.Points(geom, SPARK_MAT.clone());
            points.position.copy(pos);
            scene.add(points);

            explosions.push({ points, velocities, life:0, ttl:0.8 }); // 0.8 s
            }

        /* ----------  Conquest ring helpers  ---------- */
        function createConquestRing(star, color = 0xffa500){
            const starR = star.mesh.geometry.parameters.radius * (star.mesh.scale.x || 1);
            const r     = starR + 5;
            const geom  = new THREE.RingGeometry(r-4, r+1, 64, 1, 0, 0.0001);
            const mat   = new THREE.MeshBasicMaterial({
                color,
                side: THREE.DoubleSide,
                transparent: true,
                opacity: 0.9,

            });
            const ring  = new THREE.Mesh(geom, mat);
            ring.rotation.x = Math.PI / 2;
            ring.position.copy(star.mesh.position);
            ring.renderOrder = 10;
            ring.userData.baseR = r;
            scene.add(ring);

            console.log('▶ Valloitusrengas luodaan tähdelle', star.name);   // debug-rivi
            return ring;
        }

        function initializeSelectionIndicator() {
            selectionIndicatorMesh = new THREE.Group(); // Käytetään Group-objektia
            selectionIndicatorMesh.visible = false;
            selectionIndicatorMesh.renderOrder = 5; // Piirrä myöhään, jotta näkyy muiden päällä

            const indicatorColor = 0xffffff; // Valkoinen väri
            const baseRadius = 1.5; // Indikaattorin perussäde, jota skaalataan
            const bracketLength = baseRadius * 2.5; // Väkärän pituus
            const bracketThickness = baseRadius * 0.15; // Väkärän "paksuus" (jos käytetään Planeja)
                                                    // tai LineBasicMaterialin linewidth jos käytät Line-objekteja

            // Keskusrengas (ohuempi ja isompi)
            const ringGeometry = new THREE.TorusGeometry(baseRadius, baseRadius * 0.03, 8, 64);
            const ringMaterial = new THREE.MeshBasicMaterial({
                color: indicatorColor,
                transparent: true,
                opacity: 0.7,
                depthWrite: false,
                depthTest: false
            });
            const mainRing = new THREE.Mesh(ringGeometry, ringMaterial);
            mainRing.rotation.x = Math.PI / 2;
            selectionIndicatorMesh.add(mainRing);

            // "Väkärät" (4 kpl, 90 asteen välein)
            // Käytetään ohuita PlaneGeometry-objekteja viivojen sijaan, jotta ne näkyvät paremmin eri etäisyyksiltä
            const bracketMaterial = new THREE.MeshBasicMaterial({
                color: indicatorColor,
                side: THREE.DoubleSide,
                transparent: true,
                opacity: 0.9,
                depthWrite: false,
                depthTest: false
            });

            const bracketWidth = baseRadius * 0.3; // Väkärän "leveys" (pituus akselin suunnassa)
            const bracketHeight = baseRadius * 0.15; // Väkärän "paksuus" (korkeus pystysuunnassa)

            const positions = [
                { x: baseRadius, z: 0, rotY: Math.PI / 2 }, // Oikea
                { x: -baseRadius, z: 0, rotY: -Math.PI / 2 },// Vasen
                { x: 0, z: baseRadius, rotY: 0 },            // Alaosa (oletusrotaatio)
                { x: 0, z: -baseRadius, rotY: Math.PI }     // Yläosa
            ];

            positions.forEach(pos => {
                // Jokainen "väkärä" koostuu kahdesta osasta (L-muoto)
                // Osa 1: Säteittäinen osa
                const part1Geom = new THREE.PlaneGeometry(bracketHeight, bracketWidth); // (width, height)
                const part1 = new THREE.Mesh(part1Geom, bracketMaterial.clone());
                part1.position.set(pos.x * 0.95, 0, pos.z * 0.95); // Hieman sisäänpäin
                part1.rotation.x = Math.PI / 2;
                part1.rotation.y = pos.rotY;
                selectionIndicatorMesh.add(part1);

                // Osa 2: Kohtisuora osa (tekee L-muodon)
                // Lasketaan paikka ja rotaatio niin, että se on 90 astetta ja kiinni part1:n päässä
                const part2Geom = new THREE.PlaneGeometry(bracketHeight, bracketWidth);
                const part2 = new THREE.Mesh(part2Geom, bracketMaterial.clone());

                // Asetetaan part2:n sijainti suhteessa part1:n "ulompaan" päähän
                // ja käännetään sitä 90 astetta.
                // Tämä vaatii hieman enemmän laskentaa, jotta ne osuvat nätisti.
                // Yksinkertaisempi lähestymistapa voisi olla käyttää sprite-tekstuureja väkäröille.

                // YKSINKERTAISTETTU LÄHESTYMISTAPA VÄKÄRÖILLE (yksittäiset viivat):
                // Käytetään vain yhtä Planea per väkärä, joka osoittaa ulospäin.
                scene.remove(part1); // Poistetaan aiempi yritys
                const bracketPlaneGeom = new THREE.PlaneGeometry(bracketWidth * 0.6, bracketHeight * 2); // Lyhyempi, paksumpi
                const bracket = new THREE.Mesh(bracketPlaneGeom, bracketMaterial);
                
                // Asetetaan väkärät renkaan ulkopuolelle osoittamaan poispäin keskustasta
                const offsetFactor = 1.15; // Kuinka kauas renkaasta väkärät sijoitetaan
                bracket.position.set(pos.x * offsetFactor, 0, pos.z * offsetFactor);
                bracket.rotation.x = Math.PI / 2; // Makaa XZ-tasossa
                bracket.rotation.y = pos.rotY;    // Käännä osoittamaan oikeaan suuntaan
                selectionIndicatorMesh.add(bracket);
            });

            scene.add(selectionIndicatorMesh);
        }

        let mineIndicatorTexture;
        let popIndicatorTexture;
        let shipyardIndicatorTexture; 
        let mineSpriteMaterial;
        let popSpriteMaterial;
        let shipyardSpriteMaterial; 

        // --- AUDIO FUNCTIONS ---
        function initializeAudioNodes() { 
            if (!audioContextStarted) return; 
            console.log("Initializing Tone.js audio nodes...");

            masterVolume = new Tone.Volume(-10).toDestination(); 

            synthButtonClick = new Tone.NoiseSynth({
                noise: { type: 'white' },
                volume: -1, 
                envelope: { attack: 0.002, decay: 0.03, sustain: 0, release: 0.05 } 
            }).connect(masterVolume);

            synthButtonHoverEffect = new Tone.NoiseSynth({
                noise: { type: 'pink' }, 
                volume: -10, 
                envelope: { attack: 0.001, decay: 0.005, sustain: 0, release: 0.01 }
            }).connect(masterVolume);


            ambientPanner = new Tone.Panner(0).connect(masterVolume);
            ambientFilter = new Tone.AutoFilter({
                frequency: "8m", 
                type: "sine", depth: 0.7, baseFrequency: 60, octaves: 3,
                filter: { type: "lowpass", rolloff: -12, Q: 1 }
            }).connect(ambientPanner).start();

            ambientHum = new Tone.FatOscillator({
                frequency: 50, type: "sawtooth", detune: 0.6, spread: 15, volume: -10, 
            }).connect(ambientFilter);
            
            mineIndicatorTexture     = createSquareTexture(new THREE.Color(INDICATOR_BASE_COLOR));
            popIndicatorTexture      = createCircleTexture(new THREE.Color(INDICATOR_BASE_COLOR));
            shipyardIndicatorTexture = createOctagonTexture(new THREE.Color(INDICATOR_BASE_COLOR));

            mineSpriteMaterial = new THREE.SpriteMaterial({ map: mineIndicatorTexture, sizeAttenuation: true, transparent: true, opacity: 0.9 });
            popSpriteMaterial = new THREE.SpriteMaterial({ map: popIndicatorTexture, sizeAttenuation: true, transparent: true, opacity: 0.9 });
            shipyardSpriteMaterial = new THREE.SpriteMaterial({ map: shipyardIndicatorTexture, sizeAttenuation: true, transparent: true, opacity: 0.9});


            console.log("Tone.js audio nodes initialized.");
        }

        async function initAudio() { 
            if (audioContextStarted) return true;
            try {
                await Tone.start();
                audioContextStarted = true;
                console.log("AudioContext started by user interaction!");
                initializeAudioNodes();
                if (ambientHum && ambientHum.state !== "started") {
                    ambientHum.start();
                    console.log("AUDIO: Ambient hum started.");
                }
                return true;
            } catch (e) {
                console.error("Failed to start AudioContext:", e);
                return false;
            }
        }

        function playButtonClickSound() { 
            if (!audioContextStarted || !synthButtonClick) return;
            const now = Tone.now();
            if (now - lastButtonClickTime < BUTTON_CLICK_COOLDOWN) return;
            try {
                synthButtonClick.triggerAttackRelease("64n", now); 
                lastButtonClickTime = now;
            } catch (e) {
                console.error("Audio error playing button click sound:", e);
            }
        }

        function playButtonHoverSound() { 
            if (!audioContextStarted || !synthButtonHoverEffect) return;
            const now = Tone.now();
            if (now - lastButtonHoverTime < BUTTON_HOVER_COOLDOWN) return;
            try {
                synthButtonHoverEffect.triggerAttackRelease("128n", now); 
                lastButtonHoverTime = now;
            } catch (e) {
                console.error("Audio error playing button hover sound:", e);
            }
        }
        // --- END AUDIO FUNCTIONS ---

        // Setup AI player settings UI
        function setupAIPlayerSettings() {
            const numPlayers = parseInt(numAiPlayersSelect.value);
            aiPlayerSettingsContainer.innerHTML = '';
            
            for (let i = 0; i < numPlayers; i++) {
                const configDiv = document.createElement('div');
                configDiv.className = 'ai-player-config';
                configDiv.innerHTML = `
                    <label>AI Player ${i + 1} Color:</label>
                    <input type="color" class="ai-color-picker" data-ai-index="${i}" 
                           value="#${DEFAULT_AI_COLORS[i].toString(16).padStart(6, '0')}">
                `;
                aiPlayerSettingsContainer.appendChild(configDiv);
            }
        }

        // Initialize AI settings on page load
        setupAIPlayerSettings();
        numAiPlayersSelect.addEventListener('change', setupAIPlayerSettings);

        function init() { 
            console.log("init: Initializing scene...");
            scene = new THREE.Scene();
            createBackgroundStarfield(); 
            createNebulaSprites(); 

            const nebulaScene = new THREE.Scene();       // vain sumuja varten
            createNebulaSprites(nebulaScene);            // päivitä funktio lisäämään spritet tähän

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 5000); 
            camera.position.set(0, 100, 220); 
            renderer = new THREE.WebGLRenderer({
                canvas: gameCanvas,
                antialias: true,
                powerPreference: "high-performance", // vältä integroidun GPU:n *fail fast*
                });
            renderer.setSize(window.innerWidth, window.innerHeight);

            const ambientLight = new THREE.AmbientLight(0x909090, 1); 
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 2.5); 
            directionalLight.position.set(70, 100, 60);
            scene.add(directionalLight);

            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true; controls.dampingFactor = 0.05;
            controls.screenSpacePanning = true; controls.maxDistance = 2000; controls.minDistance = 10;
            console.log("init: Controls initialized.");

            window.addEventListener('resize', onWindowResize, false);
            
            /* Täytetään nappeihin hinnat yhdestä totuudesta (SHIP_COST) */
            syncShipButtons();

            const allButtons = document.querySelectorAll('button');
            allButtons.forEach(button => {
                button.addEventListener('mouseenter', playButtonHoverSound);
            });

            const tooltipElement = document.getElementById('custom-tooltip');
            document.querySelectorAll('#planetMenu button').forEach(btn => {
                btn.addEventListener('mouseenter', () => {
                    const tooltipText = btn.dataset.tooltipText;
                    if (tooltipText) {
                        tooltipElement.innerHTML = tooltipText;
                        const rect = btn.getBoundingClientRect();
                        tooltipElement.style.left = `${rect.left}px`;
                        tooltipElement.style.top = `${rect.bottom + 5}px`; // Aseta napin alapuolelle
                        tooltipElement.style.display = 'block';
                        tooltipElement.classList.add('visible');
                    }
                });

                btn.addEventListener('mouseleave', () => {
                    tooltipElement.classList.remove('visible');
                });
            });
            
            startGameButton.addEventListener('click', () => {
                playButtonClickSound(); 
                startNewGame(); 
            });
            resumeGameButton.addEventListener('click', () => {
                playButtonClickSound();
                resumeGame();
            });
            
            gameCanvas.addEventListener('mousedown', onCanvasMouseDown, false);
            gameCanvas.addEventListener('mousemove', onCanvasMouseMove, false);
            gameCanvas.addEventListener('mouseup', onCanvasMouseUp, false);
            gameCanvas.addEventListener('dblclick', onCanvasDoubleClick, false); 
            gameCanvas.addEventListener('contextmenu', onCanvasRightClick, false);
            
            window.addEventListener('keydown', onKeyDown, false);

            upgradeInfrastructureButton.addEventListener('click', () => { playButtonClickSound(); handleUpgradeInfrastructure(selectedStar); }); 
            buildShipyardButton.addEventListener('click', () => { playButtonClickSound(); handleBuildShipyard(selectedStar); });
            upgradeShipyardButton.addEventListener('click', () => { playButtonClickSound(); handleUpgradeShipyard(selectedStar); }); 
            buildMineButton.addEventListener('click', () => { playButtonClickSound(); handleBuildMine(selectedStar); });
            buildDefenseButton.addEventListener('click', () => { playButtonClickSound(); handleBuildDefense(selectedStar); });
            buildFighterButton.addEventListener('click', (e) => { playButtonClickSound(); handleBuildShip(selectedStar, e.currentTarget.dataset.type); }); 
            buildDestroyerButton.addEventListener('click', (e) => { playButtonClickSound(); handleBuildShip(selectedStar, e.currentTarget.dataset.type); }); 
            buildCruiserButton.addEventListener('click', (e) => { playButtonClickSound(); handleBuildShip(selectedStar, e.currentTarget.dataset.type); }); 
            buildSlipstreamFrigateButton.addEventListener('click', (e) => { playButtonClickSound(); handleBuildShip(selectedStar, e.currentTarget.dataset.type); });

            
            composer = new EffectComposer(renderer);


            /* --- 1) "pää"-renderointi, joka tuottaa syvyystekstuurin --- */
            const starsPass  = new RenderPass(scene, camera);
            starsPass.clear  = true;        // tyhjennä puskuri aluksi
            composer.addPass(starsPass);

            /* --- 2) Bokeh / syväterävyys --- */
            bokeh = new BokehPass(scene, camera, {
                focus   : 150,
                aperture: 0.00015,
                maxblur : 0.01
            });
            composer.addPass(bokeh);

            /* --- 3) Sumut päälle ilman depth-kirjoitusta --- */
            const nebulaPass = new RenderPass(nebulaScene, camera);
            nebulaPass.clear = false;       // ÄLÄ tyhjennä väripuskuria → overlay
            composer.addPass(nebulaPass);


            composer.addPass( new RenderPass( scene, camera ) );

            bokeh = new BokehPass( scene, camera, {
                focus   : 200,        // alustava arvo – ylikirjoitetaan myöhemmin
                aperture: 0.005,    // sopiva "hieman sumea" yleisnäkymä
                maxblur : 0.0006
            });
            composer.addPass( bokeh );

            document.querySelectorAll('#speedPanel button').forEach(btn=>{
                btn.addEventListener('click', ()=>{
                    const val = btn.dataset.speed;
                    document.querySelectorAll('#speedPanel button').forEach(b=>b.classList.remove('active'));

                    if(val === 'pause'){
                    isPaused = true;
                    btn.classList.add('active');
                    }else{
                    GAME_SPEED = Number(val);
                    isPaused = false;
                    btn.classList.add('active');
                    }
                });
            });

            // --- group-paneelin viitteet ---
            const groupsPanel = document.getElementById('groupsPanel');
            const groupsButtonsContainer = document.getElementById('groupsButtonsContainer');

            updateUIForGameState();
            initializeSelectionIndicator();
            animate();
            console.log("init: Initialization complete.");
        }

        /* =========  BOKEH-FOKUKSEN PÄIVITYS  ========== */
        function updateBokehFocus(){                                   
            if (!bokeh || !bokeh.materialBokeh) return;

            /* jos kohde puuttuu → palataan perus­arvoon 150 */
            const wanted = bokehFocusTarget
                ? camera.position.distanceTo(bokehFocusTarget)
                : 1500;

            /* pehmeä lerppaus ettei pompi silmissä */
            const cur = bokeh.materialBokeh.uniforms.focus.value;
            bokeh.materialBokeh.uniforms.focus.value += (wanted - cur) * 0.1
        }

        async function startNewGame() { 
            console.log("startNewGame: Called.");
            if (!audioContextStarted) {
                await initAudio(); 
            }
            gameInProgress = true; 
            gameState = 'playing';
            timeSinceLastResourceTick = 0; 
            timeSinceLastPopulationTick = 0;
            timeSinceLastAIDecision = 0; 
            
            // --- ALUSTA VALINNAT JA INDIKAATTORIT UUTTA PELIÄ VARTEN ---
            selectedStar = null; // Nollaa valittu tähti
            if (selectionIndicatorMesh) { // Jos indikaattori on olemassa
                selectionIndicatorMesh.visible = false; // Piilota se
            }
            bokehFocusTarget = null; // Nollaa bokeh-fokus
            deselectAllShips(); // Poista myös laivojen valinnat, jos tarpeen
            hidePlanetMenu(); // Piilota planeettavalikko
            // --- LOPPU ---

            // Get AI player configurations
            aiPlayers = [];
            const numAIPlayers = parseInt(numAiPlayersSelect.value);
            const colorPickers = document.querySelectorAll('.ai-color-picker');
            
            for (let i = 0; i < numAIPlayers; i++) {
                const colorHex = colorPickers[i] ? colorPickers[i].value : DEFAULT_AI_COLORS[i];
                aiPlayers.push({
                    id: `ai${i + 1}`,
                    color: parseInt(colorHex.replace('#', ''), 16),
                    resources: { credits: 1000, minerals: 500 }
                });
            }
            
            try {
                console.log("startNewGame: Clearing previous game state...");
                allShips.forEach(ship => { if(ship.mesh) scene.remove(ship.mesh); });
                allShips = [];
                starConnections.forEach(conn => scene.remove(conn));
                starConnections = [];
                starGlows.forEach(glow => scene.remove(glow)); 
                starGlows = [];
                selectedShips = [];
                controlGroups = {};
                stars.forEach(starData => { 
                    if(starData.mesh) scene.remove(starData.mesh);
                    if(starData.glowSprite) scene.remove(starData.glowSprite); 
                    if(starData.defenseRings) starData.defenseRings.forEach(ring => scene.remove(ring));
                    if(starData.mineIndicatorMeshes) starData.mineIndicatorMeshes.forEach(m => scene.remove(m)); 
                    if(starData.populationIndicatorMeshes) starData.populationIndicatorMeshes.forEach(p => scene.remove(p)); 
                    if(starData.shipyardIndicatorSprite) scene.remove(starData.shipyardIndicatorSprite); 
                    if (starData.shipyardRings)      starData.shipyardRings.forEach(r => scene.remove(r));
                    if (starData.conquestRing) {            
                        scene.remove(starData.conquestRing);
                        starData.conquestRing.geometry.dispose();
                        starData.conquestRing.material.dispose();
                        starData.conquestRing = null;       
                    }
                });
                stars = [];
                console.log("startNewGame: Cleared old game objects.");
            } catch (e) {
                console.error("startNewGame: Error during cleanup:", e);
            }
            

            
            try {
                console.log("startNewGame: Calling createWorld...");
                createWorld(); 
                console.log("startNewGame: createWorld completed.");
                console.log("startNewGame: Calling createStarConnections...");
                createStarConnections();
                console.log("startNewGame: createStarConnections completed.");
            } catch (e) {
                console.error("startNewGame: Error during world creation:", e);
            }

            playerResources = { credits: 1000, minerals: 500 };
            
            // Initialize AI resources
            aiResources.clear();
            aiPlayers.forEach(ai => {
                aiResources.set(ai.id, { credits: ai.resources.credits, minerals: ai.resources.minerals });
                window.initializeAI(ai.id, aiResources.get(ai.id), stars, allShips);
            });
            
            updateResourceDisplay();

            updateUIForGameState();
            console.log("startNewGame: Finished. UI should be updated.");
        }

        function resumeGame() {
            console.log("resumeGame: Called.");
            if (gameInProgress) {
                gameState = 'playing';
                updateUIForGameState();
            }
        }


        function returnToStartScreen() { 
            console.log("returnToStartScreen: Called.");
            if (gameInProgress) {
                gameState = 'gamePaused';
            } else {
                gameState = 'initialStartScreen';
            }
            selectedStar = null; 
            if (selectionIndicatorMesh) {
                selectionIndicatorMesh.visible = false; // Piilota rengas
            }
            deselectAllShips();
            updateUIForGameState();
        }

        function updateUIForGameState() { 
            if (!startScreenDiv || !uiContainerDiv || !controls || !selectedUnitsPanel || !startGameButton || !resumeGameButton) {
                console.error("updateUIForGameState: UI elements or controls not initialized! Cannot update UI.");
                return;
            }

            if (gameState === 'initialStartScreen' || gameState === 'gamePaused') {
                startScreenDiv.style.display = 'flex';
                uiContainerDiv.style.display = 'none';
                selectedUnitsPanel.style.display = 'none'; 
                controls.enabled = false;
                hidePlanetMenu();

                if (gameInProgress && gameState === 'gamePaused') {
                    startGameButton.textContent = 'Start New Game';
                    resumeGameButton.style.display = 'block';
                } else {
                    startGameButton.textContent = 'Start Game';
                    resumeGameButton.style.display = 'none';
                }
            } else if (gameState === 'playing') {
                startScreenDiv.style.display = 'none';
                uiContainerDiv.style.display = 'flex'; 
                updateSelectedUnitsDisplay(); // Update display based on current selection
                controls.enabled = true; 
            }
            console.log(`updateUIForGameState: gameState=${gameState}, gameInProgress=${gameInProgress}`);
        }
        
        //kartan luonti pyöreäksi dartboardiksi 
        function getRandomPosition(spread){
            const t = Math.random()*2*Math.PI;
            const r = Math.sqrt(Math.random())*spread;
            const x = Math.cos(t)*r;
            const z = Math.sin(t)*r;

            /* paksuuskerroin 0 – 1  (0 = levy, 1 = pallo) */
            const THICKNESS = 0.55;          // 0.3 ≈ ohut / 0.6 ≈ paksu

            /* skaalaa y-akselia saman r-suhteen mukaan,
            jotta keskusta on ohut ja ulkoreuna paksu  */
            const maxY = spread * THICKNESS * (r / spread);
            const y    = (Math.random()*2 - 1) * maxY;

            return new THREE.Vector3(x, y, z);
            }

        function createGlowTexture() { /* ... (same as before) ... */ 
            const canvas = document.createElement('canvas');
            canvas.width = 128;
            canvas.height = 128;
            const context = canvas.getContext('2d');
            const gradient = context.createRadialGradient(
                canvas.width / 2, canvas.height / 2, 0,
                canvas.width / 2, canvas.height / 2, canvas.width / 2
            );
            gradient.addColorStop(0, 'rgba(255,215,255,0.8)');
            gradient.addColorStop(0.3, 'rgba(255,255,200,0.5)');
            gradient.addColorStop(1, 'rgba(255,255,150,0)');
            context.fillStyle = gradient;
            context.fillRect(0, 0, canvas.width, canvas.height);
            return new THREE.CanvasTexture(canvas);
        }
        const glowTexture = createGlowTexture();

        /* ---- Soft star sprite (radiaaligradientti) --------------------------- */
        function createSoftStarTexture(){
            const c = document.createElement('canvas');   // 64 × 64 px
            c.width = c.height = 64;
            const ctx = c.getContext('2d');

            const g = ctx.createRadialGradient(32,32,0, 32,32,32);
            g.addColorStop(0.00,'rgba(255,255,255,1)');
            g.addColorStop(0.50,'rgba(255,255,255,0.6)');
            g.addColorStop(1.00,'rgba(255,255,255,0)');

            ctx.fillStyle = g;
            ctx.fillRect(0,0,64,64);

            const tex = new THREE.CanvasTexture(c);
            tex.encoding = THREE.sRGBEncoding;   // oikea gammakorjaus
            return tex;
        }
        const softStarTex = createSoftStarTexture();

        /* ---- NebulaTextureFactory.js ----------------------------------- */
        function createNebulaTexture(size = 1024) {
        const c     = document.createElement('canvas');
        c.width = c.height = size;
        const ctx   = c.getContext('2d');

        const g = ctx.createRadialGradient(
            size/2, size/2,  40,
            size/2, size/2,  size/2
        );
        g.addColorStop(0.00, 'rgba(100, 80,255,0.85)');
        g.addColorStop(0.25, 'rgba( 40, 60,200,0.55)');
        g.addColorStop(0.55, 'rgba( 220, 30,120,0.25)');
        g.addColorStop(1.00, 'rgba(  0,  0,  0,0.00)');

        ctx.fillStyle = g;
        ctx.fillRect(0,0,size,size);

        const tex = new THREE.CanvasTexture(c);
        tex.encoding   = THREE.sRGBEncoding;
        tex.needsUpdate = true;
        return tex;
        }

        /* Yhteinen map kaikille: */
        const NEBULA_TEXTURE = createNebulaTexture(768);   // 768 px ≈ 2 MB

        function buildNebulaMaterials(opacity) {
        return NEBULA_TINTS.map(col =>
            new THREE.SpriteMaterial({
                map        : NEBULA_TEXTURE,
                color      : col,
                transparent: true,
                opacity,
                blending   : THREE.AdditiveBlending,
                depthWrite : false
            })
        );
        }
        const MAT_SMALL = buildNebulaMaterials(0.06);   // index 0-4 = eri värit
        const MAT_BIG   = buildNebulaMaterials(0.18);


        function createBackgroundStarfield() { 
            const starGeometry = new THREE.BufferGeometry();
            const starMaterial = new THREE.PointsMaterial({
                map           : softStarTex,   // ← uusi tekstuuri
                color         : 0xffffff,
                size          : 1.0,
                sizeAttenuation: true,
                transparent   : true,
                depthWrite    : false          // alfareunat eivät "leikkaa" toisia tähtiä
            });

            const starVertices = [];
            for (let i = 0; i < 10000; i++) {
                const x = THREE.MathUtils.randFloatSpread(4000); 
                const y = THREE.MathUtils.randFloatSpread(4000);
                const z = THREE.MathUtils.randFloatSpread(4000);
                starVertices.push(x, y, z);
            }
            starGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starVertices, 3));
            backgroundStars = new THREE.Points(starGeometry, starMaterial);
            scene.add(backgroundStars);
        }

        function createNebulaSprites(){
            const starCount = parseInt(starCountSelect.value);
            const radius    = Math.max(2000, starCount * 14);   // isompi kuin spread
            const height    = radius * 1.2;                    // kuinka "paksu" sylinteri

            // apu: satunnaispiste sylinterin kuoressa
            const rndPos = () => {
                const angle = Math.random() * Math.PI * 2;
                const r     = Math.sqrt(Math.random()) * radius;   // √ = tasainen tiheys
                const y     = (Math.random() - 0.5) * height;      // y ylös/alas
                return new THREE.Vector3(
                    r * Math.cos(angle),
                    y,
                    r * Math.sin(angle)
                );
            };

            /* pienet filtterisprites */
            for (let i=0; i<350; i++){
                const mat  = MAT_SMALL[Math.floor(Math.random()*MAT_SMALL.length)].clone();
                mat.opacity *= 0.55;                           // hiukan läpinäkyvämpi
                const spr  = new THREE.Sprite(mat);
                const s    = THREE.MathUtils.randFloat(150, 240);
                spr.scale.set(s,s,1);
                spr.position.copy( rndPos() );
                scene.add(spr);
                nebulaSprites.push(spr);
            }

            /* isot, sumuiset "pilvet" */
            for (let i=0; i<60; i++){
                const mat  = MAT_BIG[Math.floor(Math.random()*MAT_BIG.length)].clone();
                mat.opacity *= 0.45; 
                const spr  = new THREE.Sprite(mat);
                const s    = THREE.MathUtils.randFloat(900, 1400);
                spr.scale.set(s,s,1);
                spr.position.copy( rndPos() );
                scene.add(spr);
                nebulaSprites.push(spr);
            }
        }

        

        // *********** UTILS ************** // 
        function shortName(type) {
            // poista kaikki sanat 2. välilyönnistä eteenpäin
            return type.split(' ')[0];     // "Infrastructure Upgrade" → "Infrastructure"
        }

        function pushToPlanetaryQueue(star, item){        //queue-progress barin ylläpito
            if (star.planetaryConstructionQueue.length === 0){
                star.planetaryQueueTotalTime = 0;          // uusi "sarja" alkaa
            }
            star.planetaryQueueTotalTime += item.totalTime;
            star.planetaryConstructionQueue.push(item);
        }
        window.pushToPlanetaryQueue = pushToPlanetaryQueue;

        function pushToShipQueue(star, item){

            // Jos aloitetaan uusi "sarja", nollaa kokonaisaikalaskuri
            if (star.shipConstructionQueue.length === 0){
                star.shipQueueTotalTime = 0;
            }
            // Kasvata alkuperäistä kokonaisaikaa
            star.shipQueueTotalTime += item.totalTime;

            // Työn lisäys varsinaiseen jonoon
            star.shipConstructionQueue.push(item);
        }
        window.pushToShipQueue = pushToShipQueue;

        // queuesdcount laskee montako saman tyyppistä kohdetta on jo rakennusjonossa
        function queuedCount(star, type) {
        return star.planetaryConstructionQueue.filter(item => item.type === type).length;
        }

        // progress data antaa planetary ja ship queuen progressin suhteessa koko queueen 
        function queueProgressData(queue, originalTotalTime){
            // Jos jono tyhjä → 0 %
            if (queue.length === 0 || originalTotalTime === 0){
                return { pct: 0, remaining: 0 };
            }

            // Kuinka paljon on vielä tekemättä?
            const remaining = queue.reduce((sum, itm) => sum + itm.timeLeft, 0);

            // Valmistumisprosentti suhteessa alkuperäiseen kokonaisaikaan
            const pct = 100 * (originalTotalTime - remaining) / originalTotalTime;

            return {
                pct      : Math.min(100, pct),
                remaining
            };
        }

        /* Paljonko tasoja on jo jonossa? */
        function infraUpgradesQueued(star) {
            return star.planetaryConstructionQueue
                    .filter(it => it.type.startsWith('Infrastructure')).length;
        }
        
        function shipyardUpgradesQueued(star) {
            return star.planetaryConstructionQueue
                    .filter(it => it.type.startsWith('Shipyard')).length;
        }

        /* "Todellinen" taso = valmis + jonossa */
        function effectiveInfraLevel(star) {
            return star.infrastructureLevel + infraUpgradesQueued(star);
        }
        function effectiveShipyardLevel(star) {
            return star.shipyardLevel + shipyardUpgradesQueued(star);
        }


        function updateQueueTotalBars(star) {
            /* ----- Planetary ----- */
            const pData = queueProgressData(
                star.planetaryConstructionQueue,
                star.planetaryQueueTotalTime
            );
            planetaryQueueTotalProgressFill.style.width = `${pData.pct}%`;

            if (star.planetaryConstructionQueue.length) {
                planetaryQueueTotalProgressText.textContent =
                `ETA: ${Math.ceil(pData.remaining)} s`;
            } else {
                planetaryQueueTotalProgressText.textContent = 'Idle';
            }
            planetaryQueueTotalProgressText.toggleAttribute(
                'idle',
                !star.planetaryConstructionQueue.length
            );

            /* ----- Ship ----- */
            const sData = queueProgressData(
                star.shipConstructionQueue,
                star.shipQueueTotalTime
            );
            shipQueueTotalProgressFill.style.width = `${sData.pct}%`;

            if (star.shipConstructionQueue.length) {
                shipQueueTotalProgressText.textContent =
                `ETA: ${Math.ceil(sData.remaining)} s`;
            } else {
                shipQueueTotalProgressText.textContent = 'Idle';
            }
            shipQueueTotalProgressText.toggleAttribute(
                'idle',
                !star.shipConstructionQueue.length
            );
        }

        function getOwnerName(ownerId) {
            if (ownerId === PLAYER_ID) return 'Player';
            if (ownerId === 'neutral') return 'Neutral';
            const ai = aiPlayers.find(p => p.id === ownerId);
            return ai ? `AI ${aiPlayers.indexOf(ai) + 1}` : ownerId;
        }

        function createWorld() { 
            console.log("createWorld: Called.");
            stars.forEach(starData => {
                if (starData.mesh) scene.remove(starData.mesh);
                if (starData.glowSprite) scene.remove(starData.glowSprite); 
                if (starData.defenseRings) starData.defenseRings.forEach(ring => scene.remove(ring));
                if (starData.mineIndicatorMeshes) starData.mineIndicatorMeshes.forEach(m => scene.remove(m));
                if (starData.populationIndicatorMeshes) starData.populationIndicatorMeshes.forEach(p => scene.remove(p));
                if (starData.shipyardIndicatorSprite) scene.remove(starData.shipyardIndicatorSprite);
                if (starData.shipyardRings)      starData.shipyardRings.forEach(r => scene.remove(r));
            });
            stars = [];
            selectedStar = null;
            bokehFocusTarget = null;  
            hidePlanetMenu(); 

            const count = parseInt(starCountSelect.value);
            /* 0.85-potenssi: kaksinkertainen tähtimäärä ⇒ vain ~1.8-kertainen säde */
            const spread = 220 + Math.pow(count, 0.85) * 8;   // 75★ ≈ 620  … 500★ ≈ 1950
            const starGeometry = new THREE.SphereGeometry(5, 32, 32); 
            const minHomeworldDist = spread * MIN_HOMEWORLD_DISTANCE_FACTOR;
            

            console.log(`createWorld: Creating ${count} stars with spread ${spread}. Min homeworld dist: ${minHomeworldDist.toFixed(2)}`);
            
            let homeworldPositions = [];

            for (let i = 0; i < count; i++) {
                const isPlayer = i === 0;
                const isAI = i > 0 && i <= aiPlayers.length;
                const aiIndex = i - 1;
                
                const starData = {
                    id: `star_${THREE.MathUtils.generateUUID()}`,
                    name : generateStarName(),
                    mesh: null, 
                    glowSprite: null,
                    defenseRings: [], 
                    mineIndicatorMeshes: [], 
                    populationIndicatorMeshes: [], 
                    shipyardIndicatorSprite: null, 
                    owner: isPlayer ? PLAYER_ID : (isAI ? aiPlayers[aiIndex].id : 'neutral'), 
                    infrastructureLevel: 1, // Start at level 1
                    defenseLevel: 0, 
                    defenseHP : 0,
                    population: 0, 
                    mines: 0,      
                    shipyardLevel: 0, // 0: None, 1: Shipyard, 2: Orbital Dock, 3: Drydock Complex
                    planetaryConstructionQueue: [], 
                    shipConstructionQueue: [],      
                    orbitingShips: [], 
                    isHomeworld: false, 
                    connections: [],
                    lineMeshes: [], 
                    conquestProgress: 0, 
                    isBeingConqueredBy: null,
                    conquestRatePerShip: CONQUEST_RATE_PER_SHIP,
                    planetaryQueueTotalTime: 0,
                    shipQueueTotalTime:      0, 
                    shipyardRings: []
                };
                
                // Dynamic limits based on infra level
                starData.maxPopulation = INFRA_LIMITS[starData.infrastructureLevel].maxPop;
                starData.maxMines = INFRA_LIMITS[starData.infrastructureLevel].maxMines;
                
                let starColor;
                if (isPlayer) {
                    starColor = PLAYER_COLOR;
                } else if (isAI) {
                    starColor = aiPlayers[aiIndex].color;
                } else {
                    starColor = NEUTRAL_COLOR;
                }
                
                const material = new THREE.MeshStandardMaterial({ 
                    color: starColor, 
                    emissive: starColor, 
                    emissiveIntensity: starData.owner === 'neutral' ? 0.45 : 0.3 
                });
                starData.mesh = new THREE.Mesh(starGeometry, material);
                
                const maxR     = spread;          // kiekon "säde"
                const r        = starData.mesh.position.length(); // etäisyys (0–maxR)
                const edgeFade = 0.85;            // 0.85 ⇒ viimeiset 15 % haalistuvat
                const rNorm    = r / maxR;        // 0 … 1

                if (rNorm > edgeFade){            // vain ulkokehällä
                const fade = 1 - (rNorm - edgeFade) / (1 - edgeFade); // 1 → 0
                starData.mesh.material.emissiveIntensity *= fade;     // valaistus
                // Jos haluat myös sprite-glown himmeämmäksi:
                // starData.glowSprite.material.opacity      *= fade;
                }

                let positionOk = false;
                let attempts = 0;
                while (!positionOk && attempts < 100) { 
                    starData.mesh.position.copy(getRandomPosition(spread));
                    
                    if (isPlayer || isAI) { 
                        // Check distance from all other homeworlds
                        positionOk = true;
                        for (const pos of homeworldPositions) {
                            if (starData.mesh.position.distanceTo(pos) < minHomeworldDist) {
                                positionOk = false;
                                break;
                            }
                        }
                        if (positionOk) {
                            homeworldPositions.push(starData.mesh.position.clone());
                        }
                    } else { 
                        // Regular star - just check it's not too close to any star
                        positionOk = true;
                        for (const pos of homeworldPositions) {
                            if (starData.mesh.position.distanceTo(pos) < starGeometry.parameters.radius * 5) {
                                positionOk = false;
                                break;
                            }
                        }
                    }
                    attempts++;
                }
                 
                if (!positionOk && (isPlayer || isAI)) { 
                    console.warn(`Could not place ${isPlayer ? 'player' : `AI ${aiIndex + 1}`} homeworld far enough, placing randomly.`);
                    starData.mesh.position.copy(getRandomPosition(spread)); 
                    if (isPlayer || isAI) {
                        homeworldPositions.push(starData.mesh.position.clone());
                    }
                }


                starData.mesh.userData = { entityId: starData.id, type: 'star', name: starData.name };

                const glowMaterial = new THREE.SpriteMaterial({
                    map: glowTexture,
                    color: starColor, 
                    transparent: true,
                    opacity: STAR_GLOW_DEFAULT_OPACITY, 
                    blending: THREE.AdditiveBlending,
                    depthWrite: false 
                });
                starData.glowSprite = new THREE.Sprite(glowMaterial);
                const glowSize = starGeometry.parameters.radius * STAR_GLOW_DEFAULT_SCALE; 
                starData.glowSprite.scale.set(glowSize, glowSize, 1);
                starData.glowSprite.position.copy(starData.mesh.position);
                scene.add(starData.glowSprite);
                starGlows.push(starData.glowSprite);


                if (isPlayer || isAI) { 
                    starData.isHomeworld = true;
                    starData.population = 1; 
                    starData.mines = isPlayer ? 1 : 0; 
                    starData.shipyardLevel = 1; // Start with basic shipyard
                    starData.mesh.material.emissiveIntensity = isPlayer ? 0.7 : 0.6; 
                    if (isPlayer) {
                        starData.mesh.scale.set(1.5, 1.5, 1.5);
                        starData.glowSprite.scale.set(glowSize * 1.6, glowSize * 1.6, 1); 
                    }
                } else { 
                    starData.population = 1; 
                    starData.mines = 0;
                    starData.shipyardLevel = 0;
                }
                updateDefenseRings(starData); 
                updateMineIndicators(starData);
                updatePopulationIndicators(starData);
                updateShipyardIndicator(starData); 
                scene.add(starData.mesh);
                /* Alusta puolustuksen HP tasoon × DEFENSE_HP_PER_LEVEL */
                starData.defenseHP = starData.defenseLevel * DEFENSE_HP_PER_LEVEL;
                stars.push(starData);
            }
            console.log("createWorld: Stars created.");
            if (stars.length > 0 && stars[0].owner === PLAYER_ID) { 
                controls.target.copy(stars[0].mesh.position);
                camera.position.copy(stars[0].mesh.position).add(new THREE.Vector3(0, 100, 180));
                console.log("createWorld: Camera targeted to player homeworld.");
            } else {
                camera.position.set(0, 90, 200); controls.target.set(0,0,0);
                console.log("createWorld: Camera set to default position.");
            }
            controls.update();
            console.log("createWorld: Finished.");
        }

        function createStarConnections() { 
            console.log("createStarConnections: Called.");
            const lineMaterial = new THREE.LineBasicMaterial({ color: 0xaaaaaa, transparent: true, opacity: STAR_LANE_DEFAULT_OPACITY });
            let connectionsMade = 0;
            const starCount = stars.length;                // montako tähteä tässä galaksissa
            /*  Skaalaa raja √N -suhteessa:
                – 100 tähteä  →  1.0 × perusraja
                – 150 tähteä  →  1.22 ×
                – 250 tähteä  →  1.58 ×
                – 500 tähteä  →  2.24 ×  */
            const scale = Math.sqrt(starCount / 125);          //Jos starcount / 100 ->  75★ → 0.866 … 500★ → 2.24
            const STAR_CONNECTION_MAX_DIST = STAR_CONNECTION_MAX_DIST_BASE * scale;

            // Pienennä arpaprosenttia vastaavasti
            const STAR_CONNECTION_PROB =
                STAR_CONNECTION_PROBABILITY / scale;           // 0.25 / 2.24 ≈ 0.11
            for (let i = 0; i < stars.length; i++) {
                for (let j = i + 1; j < stars.length; j++) {
                    const star1 = stars[i];
                    const star2 = stars[j];
                    if(!star1.mesh || !star2.mesh) { 
                        console.warn("createStarConnections: star mesh not found, skipping connection.");
                        continue;
                    }
                    const distance = star1.mesh.position.distanceTo(star2.mesh.position);
                    
                    let isHomeworldConnection = (star1.isHomeworld || star2.isHomeworld);
                    
                    if (distance < STAR_CONNECTION_MAX_DIST &&
                    Math.random() < STAR_CONNECTION_PROB) {
                        if (star1.connections.length < 4 && star2.connections.length < 4) { 
                            const points = [star1.mesh.position.clone(), star2.mesh.position.clone()];
                            const geometry = new THREE.BufferGeometry().setFromPoints(points);
                            const line = new THREE.Line(geometry, lineMaterial.clone()); 
                            line.userData = { star1Id: star1.id, star2Id: star2.id }; 
                            scene.add(line);
                            starConnections.push(line);
                            star1.connections.push(star2.id); 
                            star2.connections.push(star1.id);
                            star1.lineMeshes.push(line); // Add reference to line mesh
                            star2.lineMeshes.push(line); // Add reference to line mesh
                            connectionsMade++;
                        }
                    }
                }
            }
            console.log(`createStarConnections: Finished. ${connectionsMade} connections made.`);
        }
        
        function updateResourceDisplay(){
            let grossC = 0, grossM = 0, upkeepC = 0;

            /* --- planeettojen tuotot & ylläpitokulut ---------------------------- */
            stars.forEach(star=>{
                if (star.owner !== PLAYER_ID) return;
                grossC += star.population;
                grossM += star.mines;

                upkeepC += star.defenseLevel *  window.UPKEEP_PD +
                        star.shipyardLevel * window.UPKEEP_SHIPYARD;
            });

            /* --- laivaston ylläpito -------------------------------------------- */
            allShips.forEach(ship=>{
                if (ship.owner !== PLAYER_ID) return;
                upkeepC += (window.UPKEEP_SHIP[ship.type] || 0);
            });

            const netC = grossC - upkeepC;

            /* 2) apu-formaatti arvolle – punaisena jos < 0 */
            const fmtVal = v => v < 0
                ? `<span style="color:#f87171">${v}</span>`
                : v;

            /* 3) tulostus – huom. käytetään innerHTML molemmille */
            const netColor = netC >= 0 ? '#6ee7b7' : '#f87171';   // vihreä ↔ punainen

            creditsDisplay.innerHTML =
                `Credits: ${fmtVal(playerResources.credits)} ` +
                `<span style="color:${netColor};font-size:0.85em;">` +
                `(${netC>=0?'+':''}${netC}      /10s)</span>`;

            mineralsDisplay.innerHTML =
                `Minerals: ${fmtVal(playerResources.minerals)} ` +
                `<span style="color:#6ee7b7;font-size:0.85em;">(+${grossM}      /10s)</span>`;

            if (selectedStar &&
                planetMenuDiv.style.display === 'block' &&
                selectedStar.owner === PLAYER_ID) {
                showPlanetMenuForPlayer(selectedStar);   // laskee nappien disabled-tilat uudelleen
    }
        }
        
        function updateSelectedUnitsDisplay() {
            if (selectedUnitsPanel) {
                selectedUnitsPanel.textContent = `Selected Units: ${selectedShips.length}`;
                // Show panel only if playing and ships are selected
                selectedUnitsPanel.style.display = (gameState === 'playing' && selectedShips.length > 0) ? 'block' : 'none';
            }
        }

        /* ---------- GROUP UI ---------- */
        function updateGroupsPanel(){
        groupsButtonsContainer.innerHTML = '';

        Object.keys(controlGroups).forEach(key=>{
            // siivoa listasta jo tuhoutuneet alukset
            const arr = controlGroups[key].filter(s => allShips.includes(s));
            if(arr.length === 0){ controlGroups[key] = []; return; }

            // laske tyyppijakauma
            const counts = {Fighter:0, Destroyer:0, Cruiser:0};
            arr.forEach(s => counts[s.type]++);

            const btn = document.createElement('button');
            btn.className = 'group-btn';
            btn.dataset.groupId = key;
            btn.dataset.owner   = (arr[0]?.owner === PLAYER_ID ? 'player' : 'ai');
            btn.innerHTML =
            `<div style="font-weight:600;font-size:.8rem;">Group ${key}</div>
            <div>Fighters: ${counts.Fighter}</div>
            <div>Destroyers: ${counts.Destroyer}</div>
            <div>Cruisers: ${counts.Cruiser}</div>
            <div>Total: ${arr.length}</div>`;

            btn.addEventListener('click', ()=>focusGroup(key));
            groupsButtonsContainer.appendChild(btn);
        });

        // näytä / piilota koko paneeli
        groupsPanel.style.display = groupsButtonsContainer.children.length ? 'flex' : 'none';
        }

        function focusGroup(key){
        const grp = controlGroups[key];
        if(!grp || grp.length === 0 || !grp[0].mesh) return;

        const targetPos = grp[0].mesh.position.clone();
        const offset    = camera.position.clone().sub(controls.target);
        const newCamPos = targetPos.clone().add(offset);

        // kaunis lerppaus TWEENillä
        new TWEEN.Tween(controls.target)
            .to(targetPos, 750)
            .easing(TWEEN.Easing.Quadratic.Out)
            .onUpdate(()=>controls.update())
            .start();

        new TWEEN.Tween(camera.position)
            .to(newCamPos, 750)
            .easing(TWEEN.Easing.Quadratic.Out)
            .start();
        }


        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize( window.innerWidth, window.innerHeight );

            if (composer) composer.setSize( window.innerWidth, window.innerHeight );
        }
        
        function onKeyDown(event) {
            if (gameState !== 'playing') return;
            if (event.key === "Escape") returnToStartScreen();

            const numKey = parseInt(event.key);
            if (!isNaN(numKey) && numKey >= 0 && numKey <= 9) {

                /* ----------  Ctrl + numero  =  tallenna ryhmä  ---------- */
                if (event.ctrlKey || event.metaKey) {
                    event.preventDefault();
                    controlGroups[numKey] = selectedShips.filter(s => allShips.includes(s));
                    updateGroupsPanel();
                    console.log(`Control group ${numKey} set with ${controlGroups[numKey].length} ships.`);
                    return;                       // valmista
                }

                /* ----------  Pelkkä numero  =  valitse (ja mahdollinen kaksoisfokus)  ---------- */

                /* ▲ 1)  tuplapainalluksen tunnistus */
                const now = performance.now();
                if (lastGroupKey === numKey && now - lastGroupKeyAt < 350) {
                    focusGroup(numKey);           // alle 350 ms → kamera hyppää ryhmään
                }
                lastGroupKey   = numKey;
                lastGroupKeyAt = now;             // (muuttujat on luotu tiedoston yläreunassa)

                /* 2)  varsinainen valinta */
                deselectAllShips();
                const group = controlGroups[numKey];
                if (group) {
                    group.forEach(ship => { if (allShips.includes(ship)) selectShip(ship, true); });
                    controlGroups[numKey] = controlGroups[numKey].filter(s => allShips.includes(s));
                    updateGroupsPanel();
                    console.log(`Selected control group ${numKey} with ${selectedShips.length} ships.`);
                }
            }
        }

        function onCanvasMouseDown(event) { 
            if (gameState !== 'playing' || event.button !== 0) return; 
            mouseDownPosition = new THREE.Vector2(event.clientX, event.clientY); // Tallenna sijainti

            if (event.shiftKey) { // SHIFT + Drag alkaa
                isAreaSelecting = true; 
                areaAdditive   = true; // muista että lisätään valintaan
                controls.enabled = false; 
                areaSelectionStartPoint.set(event.clientX, event.clientY);

                selectionBoxElement.style.left = `${event.clientX}px`;
                selectionBoxElement.style.top = `${event.clientY}px`;
                selectionBoxElement.style.width = '0px';
                selectionBoxElement.style.height = '0px';
                selectionBoxElement.style.display = 'block'; // Make sure box is visible
            } else {
                areaAdditive = false;      // normaali LMB: uusi valinta
                }       
        }


        function onCanvasMouseMove(event) { 
            currentMousePosition.set(event.clientX, event.clientY); 
            
            // Handle area selection box update
            if (gameState === 'playing' && isAreaSelecting) {
                const x = Math.min(event.clientX, areaSelectionStartPoint.x);
                const y = Math.min(event.clientY, areaSelectionStartPoint.y);
                const width = Math.abs(event.clientX - areaSelectionStartPoint.x);
                const height = Math.abs(event.clientY - areaSelectionStartPoint.y);

                selectionBoxElement.style.left = `${x}px`;
                selectionBoxElement.style.top = `${y}px`;
                selectionBoxElement.style.width = `${width}px`;
                selectionBoxElement.style.height = `${height}px`;
                return; // Don't process hover if area selecting
            }
            
            // Handle hover effect
            if (gameState === 'playing') {
                mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
                mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
                raycaster.setFromCamera(mouse, camera);
                const starMeshes = stars.map(s => s.mesh).filter(m => m);
                const intersects = raycaster.intersectObjects(starMeshes, false);

                let currentlyHovered = null;
                if (intersects.length > 0) {
                    const firstIntersected = intersects[0].object;
                    if (firstIntersected.userData && firstIntersected.userData.type === 'star') {
                        currentlyHovered = stars.find(s => s.id === firstIntersected.userData.entityId);
                    }
                }
                hoveredStar = currentlyHovered; // Update hoveredStar (visuals updated in animate)
            } else {
                hoveredStar = null;
            }
        }

        function onCanvasMouseUp(event) {
            if (gameState !== 'playing' || event.button !== 0) return;

            const mouseUpPosition = new THREE.Vector2(event.clientX, event.clientY);
            let isDrag = false;
            if (mouseDownPosition) {
                isDrag = mouseDownPosition.distanceTo(mouseUpPosition) > CLICK_DRAG_THRESHOLD;
            }
            mouseDownPosition = null; // Nollaa seuraavaa klikkausta varten

            const clickTime = Date.now();

            if (isAreaSelecting) {
                // ... (aluevalintalogiikka pysyy samana) ...
                isAreaSelecting = false;
                controls.enabled = true;
                selectionBoxElement.style.display = 'none';
                const endPoint = new THREE.Vector2(event.clientX, event.clientY);
                selectShipsInArea(areaSelectionStartPoint, endPoint, areaAdditive);
                areaAdditive = false;
                updateSelectedUnitsDisplay(); // Lisätty, jotta valittujen yksiköiden määrä päivittyy heti
                lastClickTime = clickTime; // Lisätty, jotta double-click ei triggeröidy aluevalinnan jälkeen
                return;
            }

            // Jos oli veto (drag), älä tee mitään valinnoille (OrbitControls hoiti kameran)
            if (isDrag) {
                controls.enabled = true; // Varmista, että kontrollit ovat päällä vedon jälkeen
                lastClickTime = clickTime; // Päivitä lastClickTime estääksesi ei-toivotut tuplaklikkaukset
                return;
            }

            // Jos EI ollut veto (eli oli klikkaus)
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);

            const starMeshes = stars.map(s => s.mesh).filter(m => m);
            const shipMeshes = allShips.map(s => s.mesh).filter(m => m);
            const intersects = raycaster.intersectObjects([...starMeshes, ...shipMeshes], false);

            if (intersects.length > 0) {
                const clickedObject = intersects[0].object;
                if (clickedObject.userData && clickedObject.userData.entityId) {
                    const entityId = clickedObject.userData.entityId;
                    const type = clickedObject.userData.type;

                    if (type === 'star') {
                        const star = stars.find(s => s.id === entityId);
                        if (star) {
                            handleStarClick(star);
                        }
                    } else if (type === 'ship') {
                        // ... (laivan valintalogiikka pysyy samana) ...
                        const ship = allShips.find(s => s.id === entityId);
                        if (ship && ship.owner === PLAYER_ID) {
                            if (!event.shiftKey) {
                                deselectAllShips();
                            }
                            selectShip(ship, !selectedShips.includes(ship));
                        }
                    }
                } else {
                    console.warn("Clicked object without entityId or type in userData", clickedObject);
                }
            } else { // Klikattiin tyhjää (eikä ollut veto)
                if (selectedStar) {
                    selectedStar = null;
                    if (selectionIndicatorMesh) {
                        selectionIndicatorMesh.visible = false;
                    }
                    bokehFocusTarget = null;
                }
                deselectAllShips();
                hidePlanetMenu();
                updateAllStarVisuals();
            }

            lastClickTime = clickTime;
            updateSelectedUnitsDisplay();
            controls.enabled = true; // Varmistetaan, että OrbitControls on taas käytössä klikkauksen jälkeen
        }

        function onCanvasDoubleClick(event) { 
            if (gameState !== 'playing') return;
            
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);
            const starMeshes = stars.map(s => s.mesh).filter(m => m);
            const intersects = raycaster.intersectObjects(starMeshes, false);

            if (intersects.length > 0) {
                const clickedObject = intersects[0].object;
                if (clickedObject.userData && clickedObject.userData.type === 'star') {
                    const star = stars.find(s => s.id === clickedObject.userData.entityId);
                    if (star && star.mesh) {
                        console.log("Double clicked star:", star.id.substring(0,5));
                        
                        const targetPosition = star.mesh.position.clone();
                        const currentCamPos = camera.position.clone();
                        const currentTarget = controls.target.clone();

                        const offset = currentCamPos.clone().sub(currentTarget);
                        const newCamPos = targetPosition.clone().add(offset);

                        new TWEEN.Tween(controls.target)
                            .to(targetPosition, 750) 
                            .easing(TWEEN.Easing.Quadratic.Out)
                            .onUpdate(() => controls.update()) 
                            .start();

                        new TWEEN.Tween(camera.position)
                            .to(newCamPos, 750)
                            .easing(TWEEN.Easing.Quadratic.Out)
                            .start();
                    }
                }
            }
        }
        
        
        // additive = true  → lisätään olemassa olevaan valintaan
        function selectShipsInArea(startVec, endVec, additive = false) {
            if (!additive) deselectAllShips();      // SHIFT‑drag = additive


            const startX = Math.min(startVec.x, endVec.x);
            const startY = Math.min(startVec.y, endVec.y);
            const endX = Math.max(startVec.x, endVec.x);
            const endY = Math.max(startVec.y, endVec.y);

            let madeSelectionChange = false;
            allShips.forEach(ship => {
                if (!ship.mesh || ship.owner !== PLAYER_ID) return; 
                const screenPos = ship.mesh.position.clone().project(camera);
                const sx = (screenPos.x + 1) / 2 * window.innerWidth;
                const sy = (-screenPos.y + 1) / 2 * window.innerHeight;

                if (sx >= startX && sx <= endX && sy >= startY && sy <= endY) {
                    if (!selectedShips.includes(ship)) {
                        selectShip(ship, true); 
                        madeSelectionChange = true;
                    }
                } 
            });
            updateSelectedUnitsDisplay();
        }

        function onCanvasRightClick(event) { 
            event.preventDefault(); 
            if (gameState !== 'playing' || selectedShips.length === 0) return;

            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);
            const starMeshes = stars.map(s => s.mesh).filter(m => m); 
            const intersects = raycaster.intersectObjects(starMeshes, false);

            if (intersects.length > 0) {
                const targetStarMesh = intersects[0].object;
                if (targetStarMesh.userData && targetStarMesh.userData.entityId) {
                    const destinationStar = stars.find(s => s.id === targetStarMesh.userData.entityId);
                    if (destinationStar) {
                        // console.log(`Ordering ${selectedShips.length} ships to Star: ${destinationStar.id.substring(0,5)}`);
                        selectedShips.forEach(ship => {
                            let originStar = ship.parentStar; 
                            if (ship.state === 'moving' && ship.targetStar === null) { 
                                originStar = allShips.find(s => s.id === ship.id)?.parentStar; 
                            }
                            
                            let speed = SHIP_SPEED_SLOW;
                            if (originStar && originStar.connections.includes(destinationStar.id)) {
                                speed = SHIP_SPEED_FAST;
                                console.log(`Ship ${ship.id.substring(0,5)} using star lane. Speed: ${speed}`);
                            } else {
                                console.log(`Ship ${ship.id.substring(0,5)} not using star lane. Speed: ${speed}`);
                            }
                            // Fighter-boost vain jos ei starlanea
                            if (ship.type === 'Fighter' && speed === SHIP_SPEED_SLOW) {
                                speed = FIGHTER_SPEED_SLOW;
                            }
                            ship.currentSpeed = speed;

                            if (ship.parentStar === destinationStar && ship.state === 'orbiting') return; 

                            ship.targetStar = destinationStar;
                            ship.state = 'moving'; 
                            
                            if (ship.parentStar) {
                                const oldParentStar = stars.find(s => s.id === ship.parentStar.id); 
                                if(oldParentStar && oldParentStar.orbitingShips) {
                                    oldParentStar.orbitingShips = oldParentStar.orbitingShips.filter(s => s.id !== ship.id);
                                }
                            }
                            ship.parentStar = null; 
                        });
                    }
                }
            }
        }
        
        function selectShip(ship, doSelect) { 
            if (!ship || !ship.mesh || !ship.mesh.material || ship.owner !== PLAYER_ID) return; 
            ship.isSelected = doSelect;
            const shipBaseColor = SHIP_COLOR_PLAYER; 
            ship.mesh.material.color.setHex(ship.isSelected ? SELECTED_SHIP_COLOR : shipBaseColor);
            ship.mesh.material.emissive.setHex(ship.isSelected ? SELECTED_SHIP_COLOR : shipBaseColor);
            ship.mesh.material.emissiveIntensity = ship.isSelected ? 0.8 : 0.3; 

            if (doSelect && !selectedShips.includes(ship)) {
                selectedShips.push(ship);
            } else if (!doSelect && selectedShips.includes(ship)) {
                selectedShips = selectedShips.filter(s => s !== ship);
            }
            updateSelectedUnitsDisplay();
        }

        function deselectAllShips() { 
            selectedShips.forEach(ship => {
                if (ship && ship.mesh && ship.mesh.material && ship.owner === PLAYER_ID) { 
                    ship.isSelected = false;
                    const shipBaseColor = SHIP_COLOR_PLAYER;
                    ship.mesh.material.color.setHex(shipBaseColor);
                    ship.mesh.material.emissive.setHex(shipBaseColor);
                    ship.mesh.material.emissiveIntensity = 0.3;
                }
            });
            selectedShips = [];
            updateSelectedUnitsDisplay();
        }


        function handleStarClick(star) { 
            // Jos kutsutaan ilman tähteä tai tähdellä ei ole mesh-objektia (turvatarkistus)
            if (!star || !star.mesh) {
                console.warn("handleStarClick: star is null or has no mesh.", star);
                if (selectionIndicatorMesh) {
                    selectionIndicatorMesh.position.copy(selectedStar.mesh.position);

                    const starVisualRadius = selectedStar.mesh.geometry.parameters.radius * (selectedStar.mesh.scale.x || 1);
                    // Säädä tätä arvoa, jotta indikaattori on sopivan kokoinen tähden ympärillä
                    // Tämä on nyt koko Group-objektin skaalauskerroin.
                    // Jos initializeSelectionIndicator -funktion baseRadius oli 1.0,
                    // niin (starVisualRadius + 4.0) antaa indikaattorille säteen,
                    // joka on 4 yksikköä suurempi kuin tähden säde.
                    const desiredIndicatorScale = starVisualRadius + 200.0; // Kokeile esim. +4.0 tai +5.0 saadaksesi suuremman

                    selectionIndicatorMesh.scale.setScalar(desiredIndicatorScale);
                    selectionIndicatorMesh.visible = true;

                    // Värin vaihto (jos haluat sen olevan dynaaminen, muuten se asetetaan initialize-funktiossa)
                    // Esim. jos haluaisit sen olevan valkoinen:
                    selectionIndicatorMesh.children.forEach(child => {
                        if (child.material) {
                            child.material.color.setHex(0xffffff); // Aseta valkoinen väri kaikille osille
                        }
                    });
                }
                selectedStar = star; // Voi olla null tai validi star ilman meshiä
                bokehFocusTarget = null;
                hidePlanetMenu();
                updateAllStarVisuals(); // Päivitä glow-efektit (poistaa vanhan valinnan hehkun)
                return;
            }

            selectedStar = star;

            // --- VALINTAINDIKAATTORIN LOGIIKKA ---
            if (selectionIndicatorMesh) { // Varmista, että indikaattori on alustettu
                selectionIndicatorMesh.position.copy(selectedStar.mesh.position);

                // Laske tähden visuaalinen säde (ottaen huomioon mahdollinen skaalaus)
                const starVisualRadius = selectedStar.mesh.geometry.parameters.radius * (selectedStar.mesh.scale.x || 1);
                // Määritä indikaattorirenkaan haluttu säde (esim. 1.5 yksikköä tähden pinnasta)
                const desiredIndicatorRingRadius = starVisualRadius + 1.5;

                // Olettaen, että selectionIndicatorMesh (Torus) luotiin initializeSelectionIndicator-funktiossa
                // perussäteellä 1.0. Skaalataan koko mesh-objekti.
                // Tämä skaalaa myös putken paksuutta, mikä on usein visuaalisesti hyväksyttävää.
                selectionIndicatorMesh.scale.setScalar(desiredIndicatorRingRadius);
                selectionIndicatorMesh.visible = true; // Aseta indikaattori näkyväksi
            } else {
                // Jos selectionIndicatorMesh ei jostain syystä ole alustettu, voit alustaa sen tässä
                // tai antaa varoituksen. Parempi on varmistaa sen alustus init()-funktiossa.
                console.warn("selectionIndicatorMesh is not initialized!");
            }
            // --- VALINTAINDIKAATTORIN LOGIIKKA LOPPUU ---

            bokehFocusTarget  = null;

            // Hide all buttons initially, they will be shown in showPlanetMenuForPlayer
            buildShipyardButton.style.display = 'none';
            upgradeShipyardButton.style.display = 'none'; 
            buildMineButton.style.display = 'none';
            buildDefenseButton.style.display = 'none';
            upgradeInfrastructureButton.style.display = 'none'; 
            buildFighterButton.style.display = 'none';
            buildDestroyerButton.style.display = 'none';
            buildCruiserButton.style.display = 'none';
            planetaryConstructionProgressContainer.style.display = 'none';
            planetaryConstructingItemTypeSpan.style.display = 'none';
            shipConstructionProgressContainer.style.display = 'none';
            shipConstructingItemTypeSpan.style.display = 'none';
            conquestProgressContainer.style.display = 'none';
            conqueringStatusText.style.display = 'none';
            populationProgressContainer.style.display = 'none';

            const currentInfraLimits = INFRA_LIMITS[star.infrastructureLevel]; 

            planetMenuTitle.textContent =`Star ${star.name}${star.isHomeworld ? ' (Homeworld)' : ''}`;
            planetOwnerDisplay.textContent = `Owner: ${getOwnerName(star.owner)}`;
            planetInfraLevelDisplay.textContent = `Infrastructure Level: ${star.infrastructureLevel}`;
            planetDefenseDisplay.textContent = `Defense: ${star.defenseLevel} / ${currentInfraLimits.maxDefense}`; // Show max defense
            planetPopulationDisplay.textContent = `Population: ${star.population} / ${currentInfraLimits.maxPop}`;
            planetMinesDisplay.textContent = `Mines: ${star.mines} / ${currentInfraLimits.maxMines}`;
            planetShipyardLevelDisplay.textContent = `Shipyard Level: ${star.shipyardLevel}`;


            if (star.owner === PLAYER_ID) {
                showPlanetMenuForPlayer(star);
            } else { 
                showPlanetMenuForNonPlayer(star);
            }
            planetMenuDiv.style.display = 'block';
            // Visual update for selection happens in updateAllStarVisuals
        }

        function showPlanetMenuForPlayer(star) {
            syncShipButtons();
            const isUnderSiege = star.isBeingConqueredBy && star.isBeingConqueredBy !== PLAYER_ID;
            const currentInfraLimits = INFRA_LIMITS[star.infrastructureLevel];

            // Helper-funktio napin tilan ja tooltipin asettamiseen
            function setButtonState(button, isDisabled, tooltipText = '') {
                button.disabled = isDisabled;
                // Käytetään dataset-attribuuttia, jotta JS-event listener löytää tekstin
                button.dataset.tooltipText = isDisabled ? tooltipText : '';
            }

            // --- 1. INFRASTRUCTURE BUTTON ---
            const nextInfraLevel = effectiveInfraLevel(star) + 1;
            const canUpgradeInfra = INFRA_LIMITS[nextInfraLevel];
            upgradeInfrastructureButton.style.display = canUpgradeInfra ? 'block' : 'none';

            if (canUpgradeInfra) {
                const ic = infraCost(star.infrastructureLevel);
                const hasEnough = playerResources.credits >= ic.credits && playerResources.minerals >= ic.minerals;
                const isQueued = infraUpgradesQueued(star) > 0;
                let tooltip = '';
                let isDisabled = false;

                if (isUnderSiege) { isDisabled = true; tooltip = 'Cannot build while star is under siege.'; }
                else if (isQueued) { isDisabled = true; tooltip = 'An infrastructure upgrade is already in the queue.'; }
                else if (!hasEnough) { isDisabled = true; tooltip = `Insufficient resources. Requires: ${ic.credits}C, ${ic.minerals}M`; }
                
                setButtonState(upgradeInfrastructureButton, isDisabled, tooltip);
                upgradeInfrastructureButton.querySelector('span').textContent = `Upgrade Infra to Lvl ${ic.nextLevel} (${ic.credits}C, ${ic.minerals}M)`;
            }

            // --- 2. SHIPYARD BUTTONS ---
            const queuedYardUpgs = shipyardUpgradesQueued(star);
            const hasShipyard = star.shipyardLevel > 0 || queuedYardUpgs > 0;
            const maxShipyardLevel = currentInfraLimits.maxShipyard;
            
            buildShipyardButton.style.display = !hasShipyard ? 'block' : 'none';
            upgradeShipyardButton.style.display = hasShipyard ? 'block' : 'none';

            if (!hasShipyard) { // Build new
                const yc = shipyardCost(0);
                const hasEnough = playerResources.credits >= yc.credits && playerResources.minerals >= yc.minerals;
                let tooltip = '';
                let isDisabled = false;

                if (isUnderSiege) { isDisabled = true; tooltip = 'Cannot build while star is under siege.'; }
                else if (!hasEnough) { isDisabled = true; tooltip = `Insufficient resources. Requires: ${yc.credits}C, ${yc.minerals}M`; }

                setButtonState(buildShipyardButton, isDisabled, tooltip);
                buildShipyardButton.querySelector('span').textContent = `Build Shipyard (${yc.credits}C, ${yc.minerals}M)`;
            } else { // Upgrade existing
                const atMax = star.shipyardLevel >= maxShipyardLevel;
                const yc = shipyardCost(star.shipyardLevel);
                const nextLvl = star.shipyardLevel + 1;
                const hasEnough = playerResources.credits >= yc.credits && playerResources.minerals >= yc.minerals;
                const isQueued = queuedYardUpgs > 0;
                
                let tooltip = '';
                let isDisabled = false;

                if (isUnderSiege) { isDisabled = true; tooltip = 'Cannot upgrade while star is under siege.'; }
                else if (isQueued) { isDisabled = true; tooltip = 'A shipyard upgrade is already in the queue.'; }
                else if (atMax) { isDisabled = true; tooltip = 'Shipyard is at maximum level for this infrastructure.'; }
                else if (!hasEnough) { isDisabled = true; tooltip = `Insufficient resources. Requires: ${yc.credits}C, ${yc.minerals}M`; }
                
                setButtonState(upgradeShipyardButton, isDisabled, tooltip);

                const span = upgradeShipyardButton.querySelector('span');
                if (isQueued) { span.textContent = `Upgrading…`; }
                else if (atMax) { span.textContent = `Shipyard at Max (Lvl ${star.shipyardLevel})`; }
                else { span.textContent = `Upgrade Shipyard to Lvl ${nextLvl} (${yc.credits}C, ${yc.minerals}M)`; }
            }

            // --- 3. MINE BUTTON ---
            const mineCostC = parseInt(buildMineButton.dataset.costCredits);
            const mineCostM = parseInt(buildMineButton.dataset.costMinerals);
            const atMaxMines = star.mines + queuedCount(star, 'Mine') >= currentInfraLimits.maxMines;
            const hasEnoughForMine = playerResources.credits >= mineCostC && playerResources.minerals >= mineCostM;
            let mineTooltip = '';
            let isMineDisabled = false;

            if (isUnderSiege) { isMineDisabled = true; mineTooltip = 'Cannot build while star is under siege.'; }
            else if (atMaxMines) { isMineDisabled = true; mineTooltip = 'Maximum number of mines reached.'; }
            else if (!hasEnoughForMine) { isMineDisabled = true; mineTooltip = `Insufficient resources. Requires: ${mineCostC}C, ${mineCostM}M`; }
            
            setButtonState(buildMineButton, isMineDisabled, mineTooltip);
            buildMineButton.style.display = 'block';
            buildMineButton.querySelector('span').textContent = `Build Mine (${mineCostC}C, ${mineCostM}M)`;

            // --- 4. DEFENSE BUTTON ---
            const defenseCostC = parseInt(buildDefenseButton.dataset.costCredits);
            const defenseCostM = parseInt(buildDefenseButton.dataset.costMinerals);
            const atMaxDefense = star.defenseLevel + queuedCount(star, 'Defense Upgrade') >= currentInfraLimits.maxDefense;
            const hasEnoughForDefense = playerResources.credits >= defenseCostC && playerResources.minerals >= defenseCostM;
            let defenseTooltip = '';
            let isDefenseDisabled = false;

            if (isUnderSiege) { isDefenseDisabled = true; defenseTooltip = 'Cannot build while star is under siege.'; }
            else if (atMaxDefense) { isDefenseDisabled = true; defenseTooltip = 'Maximum defense level reached.'; }
            else if (!hasEnoughForDefense) { isDefenseDisabled = true; defenseTooltip = `Insufficient resources. Requires: ${defenseCostC}C, ${defenseCostM}M`; }
            
            setButtonState(buildDefenseButton, isDefenseDisabled, defenseTooltip);
            buildDefenseButton.style.display = 'block';
            buildDefenseButton.querySelector('span').textContent = `Upgrade Defense (${defenseCostC}C, ${defenseCostM}M)`;
            
            // --- 5. SHIP BUILD BUTTONS ---
            ['Fighter', 'Destroyer', 'Cruiser', 'Slipstream Frigate'].forEach(type => {
                const btn = document.getElementById(`build${type.replace(/ /g, '')}Button`);
                if (!btn) return;

                const [costC, costM, , requiredLvl] = SHIP_COST[type];
                btn.style.display = star.shipyardLevel >= requiredLvl ? 'block' : 'none';

                if (star.shipyardLevel >= requiredLvl) {
                    const hasEnough = playerResources.credits >= costC && playerResources.minerals >= costM;
                    let shipTooltip = '';
                    let isShipDisabled = false;

                    if (isUnderSiege) { isShipDisabled = true; shipTooltip = 'Cannot build while star is under siege.'; }
                    else if (!hasEnough) { isShipDisabled = true; shipTooltip = `Requires: ${costC}C, ${costM}M`; }
                    
                    setButtonState(btn, isShipDisabled, shipTooltip);
                }
            });

            // --- QUEUE INFO & PROGRESS BARS ---
            const nextPlanetary = star.planetaryConstructionQueue[0]?.type;
            const nextShip = star.shipConstructionQueue[0]?.type;
            planetaryQueueInfo.textContent = `Queue: ${star.planetaryConstructionQueue.length}` + (nextPlanetary ? ` (Next: ${shortName(nextPlanetary)})` : '');
            shipQueueInfo.textContent = `Queue: ${star.shipConstructionQueue.length}` + (nextShip ? ` (Next: ${shortName(nextShip)})` : '');
            updatePlanetaryConstructionProgressUI(star);
            updateShipConstructionProgressUI(star);
            updateQueueTotalBars(star);
            updatePopulationProgressUI(star);
        }

        function showPlanetMenuForNonPlayer(star) {
            updateConquestProgressUI(star);
            populationProgressContainer.style.display = 'none'; 
        }

        function updatePlanetaryConstructionProgressUI(star) {
            if (!star || star.owner !== PLAYER_ID) return;

            // Reset all button progress bars first
            const buttons = [
                upgradeInfrastructureButton, buildShipyardButton, upgradeShipyardButton,
                buildMineButton, buildDefenseButton
            ];
            buttons.forEach(button => {
                const progressBar = button.querySelector('.button-progress-bar');
                if (progressBar) progressBar.style.width = '0%';
            });
            planetaryConstructionProgressContainer.style.display = 'none'; 

            if (star.planetaryConstructionQueue.length > 0) {
                const currentItem = star.planetaryConstructionQueue[0];
                const totalBuildTime = currentItem.totalTime;
                const progress = Math.max(0, (totalBuildTime - currentItem.timeLeft) / totalBuildTime);
                const progressPercent = Math.min(100, Math.floor(progress * 100));

                let targetButtonId = '';
                let itemText = currentItem.type; 

                // Determine which button corresponds to the item type
                if (currentItem.type.startsWith('Infrastructure')) {
                    targetButtonId = 'upgradeInfrastructureButton';
                } else if (currentItem.type === 'Shipyard') {
                    targetButtonId = 'buildShipyardButton';
                } else if (currentItem.type.startsWith('Shipyard Lvl')) {
                    targetButtonId = 'upgradeShipyardButton';
                    itemText = `Upgrade Shipyard Lvl ${currentItem.targetLevel}`; 
                } else if (currentItem.type === 'Mine') {
                    targetButtonId = 'buildMineButton';
                } else if (currentItem.type === 'Defense Upgrade') {
                    targetButtonId = 'buildDefenseButton';
                }

                const targetButton = document.getElementById(targetButtonId);
                if (targetButton) {
                    const progressBar = targetButton.querySelector('.button-progress-bar');
                    if (progressBar) {
                         progressBar.style.width = `${progressPercent}%`;
                         // Set specific progress bar color based on type
                         if (currentItem.type.startsWith('Infrastructure')) {
                             progressBar.style.backgroundColor = 'rgba(139, 92, 246, 0.4)'; // Violet
                         } else if (currentItem.type.startsWith('Shipyard')) {
                              progressBar.style.backgroundColor = 'rgba(245, 158, 11, 0.4)'; // Amber
                         } else if (currentItem.type === 'Mine') {
                              progressBar.style.backgroundColor = 'rgba(250, 250, 250, 0.5)'; // Gray
                         } else if (currentItem.type === 'Defense Upgrade') {
                              progressBar.style.backgroundColor = 'rgba(239, 68, 68, 0.4)'; // Red
                         } else {
                              progressBar.style.backgroundColor = 'rgba(96, 165, 250, 0.4)'; // Default blue
                         }
                    }
                    // Show the separate text display below the buttons
                    planetaryConstructingItemTypeSpan.textContent = `Building: ${itemText} (${Math.ceil(currentItem.timeLeft)}s left)`;
                    planetaryConstructionProgressContainer.style.display = 'block';
                } else {
                    console.warn("Could not find target button for planetary progress:", targetButtonId);
                    // Show progress text even if button isn't found 
                     planetaryConstructingItemTypeSpan.textContent = `Building: ${itemText} (${Math.ceil(currentItem.timeLeft)}s left)`;
                     planetaryConstructionProgressContainer.style.display = 'block';
                }
            }
        }

        function updateShipConstructionProgressUI(star) {
            if (!star || star.owner !== PLAYER_ID) return;

            // Resetoi kaikkien alusten nappien progress barit
            // LISÄTTY UUSI NAPPI TÄNNE
            const shipButtons = [buildFighterButton, buildDestroyerButton, buildCruiserButton, buildSlipstreamFrigateButton];
            shipButtons.forEach(button => {
                if(button) { // Varmistus, että nappi on olemassa
                    const progressBar = button.querySelector('.button-progress-bar');
                    if (progressBar) progressBar.style.width = '0%';
                }
            });
            shipConstructionProgressContainer.style.display = 'none';

            if (star.shipConstructionQueue.length > 0) {
                const currentItem = star.shipConstructionQueue[0];
                const totalBuildTime = currentItem.totalTime;
                const progress = Math.max(0, (totalBuildTime - currentItem.timeLeft) / totalBuildTime);
                const progressPercent = Math.min(100, Math.floor(progress * 100));

                let targetButtonId = '';
                // LISÄTTY UUSI EHTO TÄNNE
                if (currentItem.type === 'Fighter') targetButtonId = 'buildFighterButton';
                else if (currentItem.type === 'Destroyer') targetButtonId = 'buildDestroyerButton';
                else if (currentItem.type === 'Cruiser') targetButtonId = 'buildCruiserButton';
                else if (currentItem.type === 'Slipstream Frigate') targetButtonId = 'buildSlipstreamFrigateButton';

                const targetButton = document.getElementById(targetButtonId);
                if (targetButton) {
                    const progressBar = targetButton.querySelector('.button-progress-bar');
                    if (progressBar) {
                        progressBar.style.width = `${progressPercent}%`;
                        progressBar.style.backgroundColor = 'rgba(59, 130, 246, 0.4)';
                    }
                    shipConstructingItemTypeSpan.textContent = `Building: ${currentItem.type} (${Math.ceil(currentItem.timeLeft)}s left)`;
                    shipConstructionProgressContainer.style.display = 'block';
                }
            }
        }
        

        function updatePopulationProgressUI(star) {
            if (!star || !populationProgressContainer ||
                !populationProgressBarFill || !populationProgressBarText) return;

            // päivitämme palkin vain omille planeetoille
            if (star.owner !== PLAYER_ID) {
                populationProgressContainer.style.display = 'none';
                return;
            }

            const limits = INFRA_LIMITS[star.infrastructureLevel];
            const atMax  = star.population >= limits.maxPop;

            populationProgressContainer.style.display = 'block';      // näytä aina

            if (atMax) {
                /* --- Maximi täynnä --- */
                populationProgressBarFill.style.width  = '100%';
                populationProgressBarFill.style.backgroundColor = '#4b5563'; // harmaa
                populationProgressBarText.textContent = 'Max population reached';
            } else {
                /* --- Kasvu käynnissä --- */
                const progress = (timeSinceLastPopulationTick % populationInterval) /
                                populationInterval;
                const pct = Math.floor(progress * 100);
                populationProgressBarFill.style.width  = `${pct}%`;
                populationProgressBarFill.style.backgroundColor = '#10b981'; // vihreä
                populationProgressBarText.textContent = `Growth: ${pct}%`;
            }
        }


        function updateConquestProgressUI(star) { /* ... (same as before) ... */ 
            if (!star || !conquestProgressContainer || !conquestProgressBarFill || !conquestProgressBarText || !conqueringStatusText) return;

            if (star.owner !== PLAYER_ID && star.isBeingConqueredBy) { 
                const progressPercent = Math.min(100, Math.floor(star.conquestProgress));
                conquestProgressBarFill.style.width = `${progressPercent}%`;
                conquestProgressBarText.textContent = `${progressPercent}%`;
                conqueringStatusText.textContent = `Being conquered by ${getOwnerName(star.isBeingConqueredBy)}...`;
                
                // Color based on who's conquering
                if (star.isBeingConqueredBy === PLAYER_ID) {
                    conquestProgressBarFill.style.backgroundColor = '#3b82f6'; // Blue for player
                } else {
                    // Find AI color
                    const ai = aiPlayers.find(p => p.id === star.isBeingConqueredBy);
                    const color = ai ? ai.color : 0xf59e0b;
                    conquestProgressBarFill.style.backgroundColor = `#${color.toString(16).padStart(6, '0')}`;
                }

                conquestProgressContainer.style.display = 'block';
                conqueringStatusText.style.display = 'block';
            } else {
                conquestProgressContainer.style.display = 'none';
                conqueringStatusText.style.display = 'none';
                conquestProgressBarFill.style.width = `0%`;
                conquestProgressBarText.textContent = `0%`;
            }
        }
        
        function hidePlanetMenu() { /* ... (same as before) ... */ 
            if(planetMenuDiv) planetMenuDiv.style.display = 'none'; 
            if(planetaryConstructionProgressContainer) planetaryConstructionProgressContainer.style.display = 'none'; 
            if(planetaryConstructingItemTypeSpan) planetaryConstructingItemTypeSpan.style.display = 'none';
            if(shipConstructionProgressContainer) shipConstructionProgressContainer.style.display = 'none'; 
            if(shipConstructingItemTypeSpan) shipConstructingItemTypeSpan.style.display = 'none';
            if(conquestProgressContainer) conquestProgressContainer.style.display = 'none';
            if(conqueringStatusText) conqueringStatusText.style.display = 'none';
            if(populationProgressContainer) populationProgressContainer.style.display = 'none';
        }
        
        function handleUpgradeInfrastructure(star) {
            if (!star || star.owner !== PLAYER_ID || (star.isBeingConqueredBy && star.isBeingConqueredBy !== PLAYER_ID)) return;
            const nextLevel = effectiveInfraLevel(star) + 1;
            if (!INFRA_LIMITS[nextLevel]) return;              // maksimi
            if (infraUpgradesQueued(star) > 0) return;         // jo jonossa

            const cost = infraCost(star.infrastructureLevel);

            if (playerResources.credits >= cost.credits &&
                playerResources.minerals >= cost.minerals) {
                playerResources.credits  -= cost.credits;
                playerResources.minerals -= cost.minerals;
                
                pushToPlanetaryQueue(star, {
                    type:`Infrastructure Lvl ${cost.nextLevel}`,
                    timeLeft:cost.time, 
                    totalTime:cost.time,
                    id: `build_infra_${THREE.MathUtils.generateUUID()}`,
                    targetLevel: nextLevel // Store target level
                });
                updateResourceDisplay();
                handleStarClick(star);
                console.log(`Infrastructure Lvl ${nextLevel} added to planetary queue at star ${star.id.substring(0,5)}.`);
            }
        }


        function handleBuildShip(star, shipType) {
            // 1. Perustarkistukset
            if (!star || star.owner !== PLAYER_ID || star.shipyardLevel === 0 || (star.isBeingConqueredBy && star.isBeingConqueredBy !== PLAYER_ID)) {
                return;
            }

            // 2. Hae aluksen tiedot ja vaatimukset suoraan SHIP_COST-objektista
            const shipStats = SHIP_COST[shipType];
            if (!shipStats) {
                console.error(`Unknown shipType: ${shipType}`);
                return;
            }

            const [creditsCost, mineralsCost, buildTime, requiredLvl] = shipStats;

            // 3. Tarkista, että telakan taso riittää
            if (star.shipyardLevel < requiredLvl) {
                console.log(`Cannot build ${shipType}, shipyard level ${star.shipyardLevel} is too low. Requires ${requiredLvl}.`);
                return;
            }

            // 4. Tarkista resurssit
            if (playerResources.credits < creditsCost || playerResources.minerals < mineralsCost) {
                console.log(`Not enough resources to build ${shipType}.`);
                return;
            }

            // 5. Kaikki tarkistukset ok -> Suorita rakentaminen
            playerResources.credits -= creditsCost;
            playerResources.minerals -= mineralsCost;

            pushToShipQueue(star, {
                type: shipType,
                timeLeft: buildTime,
                totalTime: buildTime,
                id: `build_${THREE.MathUtils.generateUUID()}`
            });

            // 6. Päivitä käyttöliittymä
            updateResourceDisplay();
            handleStarClick(star); // Päivittää valikon näyttämään jonon muutoksen
            console.log(`${shipType} added to ship queue at star ${star.id.substring(0,5)}`);
        }
        
        function handleUpgradeShipyard(star) {
             if (!star || star.owner !== PLAYER_ID || star.shipyardLevel === 0 || (star.isBeingConqueredBy && star.isBeingConqueredBy !== PLAYER_ID)) return;
            const nextLevel = effectiveShipyardLevel(star) + 1;
            if (shipyardUpgradesQueued(star) > 0) return; // jo jonossa
            if (nextLevel > INFRA_LIMITS[star.infrastructureLevel].maxShipyard) return;

             const cost = shipyardCost(star.shipyardLevel);

            if (playerResources.credits >= cost.credits && playerResources.minerals >= cost.minerals) {
                playerResources.credits  -= cost.credits;
                playerResources.minerals -= cost.minerals;
                
                pushToPlanetaryQueue(star, {
                    type:`Shipyard Lvl ${cost.nextLevel}`,
                    timeLeft:cost.time, 
                    totalTime:cost.time,
                    id: `build_shipyard_upg_${THREE.MathUtils.generateUUID()}`,
                    targetLevel: nextLevel 
                });
                updateResourceDisplay();
                handleStarClick(star);
                console.log(`Shipyard Lvl ${nextLevel} added to planetary queue at star ${star.id.substring(0,5)}.`);
            }
        }


        function handleBuildMine(star) { 
            if (!star || star.owner !== PLAYER_ID ||
                /* kapasiteetti täynnä, kun nykyiset + jonossa olevat >= max */
                star.mines + queuedCount(star,'Mine') >=
                    INFRA_LIMITS[star.infrastructureLevel].maxMines ||            
                (star.isBeingConqueredBy && star.isBeingConqueredBy !== PLAYER_ID)) return;
            const creditsCost = parseInt(buildMineButton.dataset.costCredits);
            const mineralsCost = parseInt(buildMineButton.dataset.costMinerals);
            const buildTime = parseInt(buildMineButton.dataset.buildTime) || 10;


            if (playerResources.credits >= creditsCost && playerResources.minerals >= mineralsCost) {
                playerResources.credits -= creditsCost;
                playerResources.minerals -= mineralsCost;
                
                pushToPlanetaryQueue(star, {
                    type: 'Mine',
                    timeLeft: buildTime,
                    totalTime: buildTime,
                    id: `build_${THREE.MathUtils.generateUUID()}`
                });
                updateResourceDisplay();
                handleStarClick(star); 
                console.log(`Mine added to planetary queue at star ${star.id.substring(0,5)}.`);
            } else {
                console.log("Not enough resources to build a mine or max mines reached.");
            }
        }

        function handleBuildDefense(star) { 
        if (!star || star.owner !== PLAYER_ID ||
            star.defenseLevel + queuedCount(star,'Defense Upgrade') >=
                INFRA_LIMITS[star.infrastructureLevel].maxDefense ||
            (star.isBeingConqueredBy && star.isBeingConqueredBy !== PLAYER_ID)) return;

            const creditsCost = parseInt(buildDefenseButton.dataset.costCredits);
            const mineralsCost = parseInt(buildDefenseButton.dataset.costMinerals);
            const buildTime = parseInt(buildDefenseButton.dataset.buildTime) || 15;

            if (playerResources.credits >= creditsCost && playerResources.minerals >= mineralsCost) {
                playerResources.credits -= creditsCost; 
                playerResources.minerals -= mineralsCost;
                pushToPlanetaryQueue(star, {
                    type: 'Defense Upgrade', 
                    timeLeft: buildTime,
                    totalTime: buildTime,
                    id: `build_${THREE.MathUtils.generateUUID()}`
                });
                updateResourceDisplay(); 
                handleStarClick(star); 
                console.log(`Defense Upgrade added to planetary queue at star ${star.id.substring(0,5)}.`);
            }
        }

        function spawnShip(parentStar, shipType) {
            if (!parentStar || !parentStar.mesh) {
                console.error("spawnShip: parentStar or its mesh is undefined.");
                return;
            }
            const shipId = `ship_${THREE.MathUtils.generateUUID()}`;
            let shipGeometry;
            let hp = 1;

            // --- Geometrian valinta ---
            if (shipType === 'Destroyer') {
                shipGeometry = new THREE.CylinderGeometry(0.7, 0.7, 4.5, 8);
                shipGeometry.rotateX(Math.PI / 2);
                hp = 2;
            } else if (shipType === 'Cruiser') {
                const radius = 1.1;
                shipGeometry = new THREE.SphereGeometry(radius, 18, 14);
                shipGeometry.scale(2.5, 1.8, 3.8);
                hp = 3;
            } else if (shipType === 'Slipstream Frigate') {
                shipGeometry = new THREE.ConeGeometry(1.2, 5, 4);
                shipGeometry.rotateX(Math.PI / 2);
                shipGeometry.scale(1, 0.7, 1.2);
                hp = 1;
            } else { // Fighter (default)
                shipGeometry = new THREE.ConeGeometry(1, 3, 4);
                shipGeometry.rotateX(Math.PI / 2);
                hp = 1;
            }

            // --- Materiaalin ja Meshin luonti ---
            const shipBaseColor = parentStar.owner === PLAYER_ID ? SHIP_COLOR_PLAYER :
                aiPlayers.find(ai => ai.id === parentStar.owner)?.color || 0xdc3545;
            const shipMaterial = new THREE.MeshStandardMaterial({
                color: shipBaseColor, emissive: shipBaseColor, emissiveIntensity: 0.3
            });
            const shipMesh = new THREE.Mesh(shipGeometry, shipMaterial); // Luodaan shipMesh TÄSSÄ

            // --- ERIKOISTOIMINNOT (kuten kupla) TULEVAT TÄNNE ---
            if (shipType === 'Slipstream Frigate') {
                const SLIPSTREAM_RADIUS_VISUAL = 25 * 1.5;
                const bubbleGeometry = new THREE.SphereGeometry(SLIPSTREAM_RADIUS_VISUAL, 32, 16);
                const bubbleMaterial = new THREE.MeshBasicMaterial({
                    color: 0xaaddff,
                    transparent: true,
                    opacity: 0.1,
                    blending: THREE.AdditiveBlending,
                    depthWrite: false,
                });
                const bubbleMesh = new THREE.Mesh(bubbleGeometry, bubbleMaterial);
                bubbleMesh.renderOrder = -1;
                shipMesh.add(bubbleMesh); // Nyt tämä on turvallista, koska shipMesh on olemassa
            }

            // --- Aluksen paikoitus ja datan tallennus ---
            const offsetRadius = (parentStar.mesh.geometry.parameters.radius * (parentStar.mesh.scale.x || 1)) + 6;
            const randomAngle = Math.random() * Math.PI * 2;
            shipMesh.position.copy(parentStar.mesh.position);
            shipMesh.position.x += offsetRadius * Math.cos(randomAngle);
            shipMesh.position.z += offsetRadius * Math.sin(randomAngle);
            shipMesh.position.y = parentStar.mesh.position.y + (Math.random() - 0.5) * 2;

            shipMesh.userData = { entityId: shipId, type: 'ship', owner: parentStar.owner };

            const shipData = {
                id: shipId, mesh: shipMesh, owner: parentStar.owner, type: shipType,
                hp: hp, maxHp: hp,
                parentStar: parentStar, state: 'orbiting', isSelected: false, targetStar: null,
                orbitAngle: randomAngle, orbitRadius: offsetRadius + Math.random() * 6,
                orbitSpeed: 0.15 + Math.random() * 0.15,
                currentSpeed: SHIP_SPEED_SLOW
            };

            parentStar.orbitingShips.push(shipData);
            allShips.push(shipData);
            scene.add(shipMesh);
        }

        function getShipsAtStar(star, ownerId = null) { 
            let ships = allShips.filter(ship => ship.parentStar === star && (ship.state === 'orbiting' || ship.state === 'conquering'));
            if (ownerId) {
                ships = ships.filter(ship => ship.owner === ownerId);
            }
            return ships;
        }

        function runEnemyAI(delta){
            timeSinceLastAIDecision += delta;
            if(timeSinceLastAIDecision < aiDecisionInterval) return;
            timeSinceLastAIDecision = 0;

            // Run AI for each AI player
            aiPlayers.forEach(ai => {
                window.runExternalEnemyAI(ai.id);
            });
        }



        function animate() { 
            requestAnimationFrame(animate);
            const delta = isPaused ? 0 : clock.getDelta() * GAME_SPEED;
            timeSinceLastResourceTick += delta;
            timeSinceLastPopulationTick += delta;
            timeSinceLastCombatCheck += delta;
            TWEEN.update(clock.getElapsedTime() * 1000); 

            /*  Räjähdysten animointi  */
            explosions.forEach((ex,idx)=>{
                ex.life += delta;
                const f = ex.life/ex.ttl;
                ex.points.material.opacity = 1-f;            // haalistus
                const posAttr = ex.points.geometry.attributes.position;
                for(let i=0;i<ex.velocities.length;i++){
                    const v = ex.velocities[i];
                    posAttr.array[i*3  ] += v.x * delta;
                    posAttr.array[i*3+1] += v.y * delta;
                    posAttr.array[i*3+2] += v.z * delta;
                }
                posAttr.needsUpdate = true;
                if (ex.life >= ex.ttl){
                    scene.remove(ex.points);
                    explosions.splice(idx,1);
                }
            });

            if (gameState === 'playing') {
                if(controls.enabled) controls.update(); 
                updateBokehFocus();
                runEnemyAI(delta); 
                updateAllStarVisuals(); 
                if (selectionIndicatorMesh && selectionIndicatorMesh.visible) {
                    // Pyöritetään koko Group-objektia sen oman Y-akselin ympäri.
                    // Koska Group-objektin rotaatio on oletuksena (0,0,0) ja sen lapset
                    // (rengas ja väkärät) on aseteltu makaamaan sen paikallisessa XZ-tasossa,
                    // tämä pyörittää niitä kaikkia yhdessä "levysoitinmaisesti" maailman Y-akselin ympäri.
                    selectionIndicatorMesh.rotation.y += SELECTION_INDICATOR_ROTATION_SPEED * delta;
                }

                if (timeSinceLastResourceTick >= resourceInterval) {
                    stars.forEach(star => {
                        /* --- ① tuotto väestöstä & kaivoksista --- */
                        if (star.owner === PLAYER_ID) {
                            playerResources.credits  += star.population;
                            playerResources.minerals += star.mines;
                        } else if (star.owner !== 'neutral') {
                            const resources = aiResources.get(star.owner);
                            if (resources) {
                                resources.credits  += star.population;
                                resources.minerals += star.mines;
                            }
                        }

                        /* --- ② ylläpitokulut planeetan rakenteista --- */
                        const upkeepHere =
                            star.defenseLevel  * UPKEEP_PD +
                            star.shipyardLevel * UPKEEP_SHIPYARD;

                        if (star.owner === PLAYER_ID) {
                            playerResources.credits -= upkeepHere;
                        } else if (star.owner !== 'neutral') {
                            const resources = aiResources.get(star.owner);
                            if (resources) resources.credits -= upkeepHere;
                        }
                    });

                    /* --- ③ ylläpitokulut laivastosta --- */
                    allShips.forEach(ship => {
                        const fee = UPKEEP_SHIP[ship.type] || 0;
                        if (fee === 0) return;          // varmistus
                        if (ship.owner === PLAYER_ID) {
                            playerResources.credits -= fee;
                        } else if (ship.owner !== 'neutral') {
                            const resources = aiResources.get(ship.owner);
                            if (resources) resources.credits -= fee;
                        }
                    });
                    updateResourceDisplay();
                    timeSinceLastResourceTick = 0;
                }

                if (timeSinceLastPopulationTick >= populationInterval) {
                    stars.forEach(star => {
                        const currentInfraLimits = INFRA_LIMITS[star.infrastructureLevel];
                        if (star.population < currentInfraLimits.maxPop) { // Use dynamic limit
                           if (star.owner !== 'neutral') { 
                                star.population += 1;
                                updatePopulationIndicators(star); 
                           }
                        }
                    });
                    timeSinceLastPopulationTick = 0; 
                }
                if (selectedStar && selectedStar.owner === PLAYER_ID && planetMenuDiv.style.display === 'block') {
                     updatePopulationProgressUI(selectedStar);
                }


                stars.forEach(star => { 
                    // Process Planetary Construction Queue (Player and AI)
                    if (star.planetaryConstructionQueue.length > 0) { 
                        const currentItem = star.planetaryConstructionQueue[0];
                        currentItem.timeLeft -= delta;
                        if (currentItem.timeLeft <= 0) {
                            if (currentItem.type === 'Mine') {
                                // mitä raja tällä hetkellä sallii?
                                const lim = INFRA_LIMITS[star.infrastructureLevel].maxMines;
                                if (star.mines < lim) {
                                    star.mines += 1;
                                    updateMineIndicators(star);
                                } else {
                                    // kapasiteetti täynnä → palautetaan kulut
                                    const REFUND_C = 75, REFUND_M = 25;
                                    if (star.owner === PLAYER_ID) {
                                        playerResources.credits  += REFUND_C;
                                        playerResources.minerals += REFUND_M;
                                    } else if (star.owner !== 'neutral') {
                                        const resources = aiResources.get(star.owner);
                                        if (resources) {
                                            resources.credits  += REFUND_C;
                                            resources.minerals += REFUND_M;
                                        }
                                    }
                                    console.log(
                                        `[AI-fix] Mine discarded at ${star.name}; refund ${REFUND_C}C/${REFUND_M}M`
                                    );
                                }
                            } else if (currentItem.type === 'Shipyard') { // Building level 1
                                star.shipyardLevel = 1;
                                updateShipyardIndicator(star);
                                console.log(`${star.owner} Shipyard construction complete at ${star.id.substring(0,5)}.`);
                            } else if (currentItem.type.startsWith('Shipyard Lvl')) { // Upgrading
                                star.shipyardLevel = currentItem.targetLevel;
                                updateShipyardIndicator(star);
                                console.log(`${star.owner} Shipyard Upgrade to Lvl ${star.shipyardLevel} complete at ${star.id.substring(0,5)}.`);
                            } else if (currentItem.type === 'Defense Upgrade') {
                                star.defenseLevel += 1;
                                star.defenseHP    += DEFENSE_HP_PER_LEVEL;
                                updateDefenseRings(star); 
                                console.log(`${star.owner} Defense Upgrade complete at ${star.id.substring(0,5)}. Level: ${star.defenseLevel}`);
                            } else if (currentItem.type.startsWith('Infrastructure Lvl')) { // Infra upgrade
                                star.infrastructureLevel = currentItem.targetLevel;
                                star.maxPopulation = INFRA_LIMITS[star.infrastructureLevel].maxPop; // Update limits
                                star.maxMines = INFRA_LIMITS[star.infrastructureLevel].maxMines;
                                console.log(`${star.owner} Infrastructure Upgrade to Lvl ${star.infrastructureLevel} complete at ${star.id.substring(0,5)}.`);
                            }
                            star.planetaryConstructionQueue.shift();
                            if (selectedStar === star && star.owner === PLAYER_ID) handleStarClick(star); 
                            if (star.planetaryConstructionQueue.length === 0){
                                star.planetaryQueueTotalTime = 0;
                            }
                        }
                    }

                    // Process Ship Construction Queue (Player and Enemy)
                    if (star.shipConstructionQueue.length > 0) { 
                        const currentItem = star.shipConstructionQueue[0];
                        currentItem.timeLeft -= delta;
                        if (currentItem.timeLeft <= 0) {
                            spawnShip(star, currentItem.type); 
                            star.shipConstructionQueue.shift(); 
                            if (selectedStar === star && star.owner === PLAYER_ID) handleStarClick(star); 
                        }
                    }

                    // Update UI if this star's menu is open
                    if (selectedStar === star && planetMenuDiv.style.display === 'block') {
                        // Päivitä aina näkyvät palkit
                        updateQueueTotalBars(star);
                        updateConquestProgressUI(star);

                        // Nämä tarvitset vain omille, koska niissä on nappien overlay‑palkit
                        if (star.owner === PLAYER_ID) {
                            updatePlanetaryConstructionProgressUI(star);
                            updateShipConstructionProgressUI(star);
                        }
                        updateConquestProgressUI(star); 
                        if (star.shipConstructionQueue.length === 0){
                            star.shipQueueTotalTime = 0;
                        }
                    }
                });

                // Combat Check
                if (timeSinceLastCombatCheck >= COMBAT_CHECK_INTERVAL) {
                    stars.forEach(star => resolveCombatAtStar(star));
                    timeSinceLastCombatCheck = 0;
                }

                // SLIPSTREAM FRIGATE LOGIC
                const slipstreamFrigates = allShips.filter(s => s.type === 'Slipstream Frigate');
                const SLIPSTREAM_RADIUS = 25 * 1.5; // Noin 1.5x kiertoradan säde
                const SLIPSTREAM_SPEED = 20;

                // Nollaa ensin kaikkien alusten slipstream-tila
                allShips.forEach(s => s.isInSlipstream = false);

                if (slipstreamFrigates.length > 0) {
                    // Etsi kaikki pelaajan alukset, jotka eivät ole jo nopealla tähtiväylällä
                    const potentialTargets = allShips.filter(s =>
                        s.owner === PLAYER_ID &&
                        s.state === 'moving' &&
                        s.currentSpeed !== SHIP_SPEED_FAST
                    );

                    slipstreamFrigates.forEach(frigate => {
                        if (!frigate.mesh) return;
                        const frigatePos = frigate.mesh.position;

                        potentialTargets.forEach(targetShip => {
                            if (targetShip.isInSlipstream || !targetShip.mesh) return; // Jos jo toisessa kuplassa

                            if (targetShip.mesh.position.distanceTo(frigatePos) < SLIPSTREAM_RADIUS) {
                                targetShip.isInSlipstream = true;
                            }
                        });
                    });
                }

                allShips.forEach(ship => { 
                        // Aseta nopeus slipstream-tilan perusteella
                    if (ship.state === 'moving' && ship.currentSpeed !== SHIP_SPEED_FAST) {
                        if (ship.isInSlipstream) {
                            ship.currentSpeed = SLIPSTREAM_SPEED;
                        } else {
                            // Palauta normaaliin hitaaseen nopeuteen, jos ei enää kuplassa
                            ship.currentSpeed = (ship.type === 'Fighter') ? FIGHTER_SPEED_SLOW : SHIP_SPEED_SLOW;
                        }
                    }
                    if (!ship.mesh) return; 

                    if (ship.state === 'orbiting' && ship.parentStar && ship.parentStar.mesh) { 
                        ship.orbitAngle += ship.orbitSpeed * delta;
                        ship.mesh.position.x = ship.parentStar.mesh.position.x + ship.orbitRadius * Math.cos(ship.orbitAngle);
                        ship.mesh.position.z = ship.parentStar.mesh.position.z + ship.orbitRadius * Math.sin(ship.orbitAngle);
                        ship.mesh.position.y = ship.parentStar.mesh.position.y + Math.sin(ship.orbitAngle * 0.5) * 2; 
                        ship.mesh.lookAt(ship.parentStar.mesh.position); 

                        // Ships attempt to conquer - check for any enemy ships
                        if (ship.parentStar.owner !== ship.owner && !ship.parentStar.isBeingConqueredBy) { 
                            const enemyShipsAtStar = getShipsAtStar(ship.parentStar).filter(s => s.owner !== ship.owner);
                            if (enemyShipsAtStar.length === 0) { 
                                ship.state = 'conquering';
                                ship.parentStar.isBeingConqueredBy = ship.owner;
                                ship.parentStar.conquestProgress = 0; 
                                const tgtStar = ship.parentStar;            // selkeyden vuoksi muuttuja
                                if (!tgtStar.conquestRing) {
                                    const ringColor = 0xffa500;             // tai pelaajakohtainen väri
                                    tgtStar.conquestRing = createConquestRing(tgtStar, ringColor);
                                    tgtStar.conquestRing.renderOrder = 1;   // piirretään aina tähden päälle
                                }
                            }
                        }

                    } else if (ship.state === 'moving' && ship.targetStar && ship.targetStar.mesh) {
                        const targetPosition = ship.targetStar.mesh.position;
                        const direction = targetPosition.clone().sub(ship.mesh.position).normalize();
                        const distanceToTarget = ship.mesh.position.distanceTo(targetPosition);
                        const arrivalThreshold = (ship.targetStar.mesh.geometry.parameters.radius * (ship.targetStar.mesh.scale.x || 1) ) + 5;

                        if (distanceToTarget > arrivalThreshold) { 
                            ship.mesh.position.add(direction.multiplyScalar(ship.currentSpeed * delta)); 
                            ship.mesh.lookAt(targetPosition);
                        } else { 
                            //console.log(`Ship ${ship.id.substring(0,5)} (Owner: ${ship.owner}) arrived at star ${ship.targetStar.id.substring(0,5)}`);
                            ship.parentStar = ship.targetStar; 
                            if (!ship.parentStar.orbitingShips) ship.parentStar.orbitingShips = [];
                            ship.parentStar.orbitingShips.push(ship); 
                            ship.targetStar = null; 
                            
                            ship.orbitRadius = (ship.parentStar.mesh.geometry.parameters.radius * (ship.parentStar.mesh.scale.x || 1)) + 6 + Math.random() * 6;
                            ship.orbitAngle = Math.random() * Math.PI * 2;
                            ship.currentSpeed = SHIP_SPEED_SLOW; 

                            // Upon arrival, check if can start conquering immediately
                            const enemyShipsAtNewStar = getShipsAtStar(ship.parentStar).filter(s => s.owner !== ship.owner);

                            if (ship.parentStar.owner !== ship.owner) {
                                if (enemyShipsAtNewStar.length === 0) { // No enemy ships, can conquer
                                    ship.state = 'conquering';
                                    if(ship.parentStar.isBeingConqueredBy !== ship.owner) ship.parentStar.conquestProgress = 0;
                                    ship.parentStar.isBeingConqueredBy = ship.owner;
                                    const tgtStar = ship.parentStar;
                                    if (!tgtStar.conquestRing) {
                                        const ringColor = 0xffa500; // Oranssi oletuksena
                                        // Voit halutessasi hakea pelaajan/AI:n värin tässä:
                                        let conquerorColorHex = 0xffa500; // Oletusoranssi
                                        if (tgtStar.isBeingConqueredBy === PLAYER_ID) {
                                            conquerorColorHex = PLAYER_COLOR;
                                        } else {
                                            const conquerorAI = aiPlayers.find(ai => ai.id === tgtStar.isBeingConqueredBy);
                                        if (conquerorAI) conquerorColorHex = conquerorAI.color;
                                        }
                                        tgtStar.conquestRing = createConquestRing(tgtStar, conquerorColorHex);
                                        tgtStar.conquestRing.renderOrder = 1; // Varmistaa piirtojärjestyksen
                                    }
                                } else { // Enemy ships present, combat will resolve first
                                    ship.state = 'orbiting'; 
                                }
                            } else { // Arrived at a friendly star
                                ship.state = 'orbiting'; 
                            }
                        }
                    } else if (ship.state === 'conquering' && ship.parentStar && ship.parentStar.owner !== ship.owner) { 
                        ship.orbitAngle += ship.orbitSpeed * delta * 0.5; 
                        ship.mesh.position.x = ship.parentStar.mesh.position.x + ship.orbitRadius * Math.cos(ship.orbitAngle);
                        ship.mesh.position.z = ship.parentStar.mesh.position.z + ship.orbitRadius * Math.sin(ship.orbitAngle);
                        ship.mesh.position.y = ship.parentStar.mesh.position.y + Math.sin(ship.orbitAngle * 0.25) * 1;
                        ship.mesh.lookAt(ship.parentStar.mesh.position);
                    }
                });

                // Conquest Progress Logic (for all factions)
                stars.forEach(star => {
                    if (star.owner !== star.isBeingConqueredBy && star.isBeingConqueredBy !== null) {
                        const conqueringFaction = star.isBeingConqueredBy;
                        const defendingFaction = star.owner; 

                        const conqueringShips = allShips.filter(s => s.parentStar === star && s.owner === conqueringFaction);
                        const defendingShipsPresent = getShipsAtStar(star, defendingFaction).length > 0;


                        if (defendingShipsPresent && conqueringFaction !== defendingFaction) { 
                            console.log(`Conquest of ${star.id.substring(0,5)} by ${conqueringFaction} halted, defending ships of ${defendingFaction} detected.`);
                            star.isBeingConqueredBy = null; 
                            conqueringShips.forEach(s => s.state = 'orbiting'); 
                            if (selectedStar === star) updateConquestProgressUI(star); 
                            return; 
                        }

                        if (conqueringShips.length > 0) {
                            /*-----------------------------------------------------------
                            +   Starbase-hidastus: jokainen taso puolittaa etenemisnopeuden
                            +   ( = 100 % hitaampi per taso → nopeus / 2^lvl )
                            +-----------------------------------------------------------*/
                            const yardLvl = Math.min(star.shipyardLevel || 0, 5); // clamp 0–5
                            const slowdownRatio = 1 / Math.pow(2, yardLvl);         // Jokainen yard-taso puolittaa valloitusnopeuden (1, ½, ¼, ...)

                            const deltaPts = conqueringShips.reduce(
                                (sum, s) => sum + (s.type === 'Cruiser' ? 3 : 1), 0
                            ) * delta * slowdownRatio;
                            star.conquestProgress += deltaPts;
                            if (star.conquestProgress >= 100) {
                                //console.log(`Star ${star.id.substring(0,5)} conquered by ${conqueringFaction}!`);
                                const oldOwner = star.owner; 
                                const oldMines = star.mines;
                                const oldShipyardLevel = star.shipyardLevel; // Preserve shipyard level

                                star.owner = conqueringFaction;
                                star.population = 1; 
                                star.shipyardLevel = oldShipyardLevel; // Shipyard level persists

                                // Mine attrition logic
                                if (oldMines > 0) {
                                    const maxMinesToDestroy = Math.ceil(oldMines * 0.5);
                                    const minesDestroyed = oldMines === 1 ? 1 : Math.max(1, Math.floor(Math.random() * maxMinesToDestroy) + 1);
                                    star.mines = Math.max(0, oldMines - minesDestroyed);
                                    // console.log(`${minesDestroyed} mines destroyed during conquest of ${star.id.substring(0,5)}. Remaining: ${star.mines}`);
                                } else {
                                    star.mines = 0;
                                }
                                
                                // Update star color
                                let newColor;
                                if (star.owner === PLAYER_ID) {
                                    newColor = PLAYER_COLOR;
                                } else {
                                    const ai = aiPlayers.find(p => p.id === star.owner);
                                    newColor = ai ? ai.color : NEUTRAL_COLOR;
                                }
                                
                                star.mesh.material.color.setHex(newColor);
                                star.mesh.material.emissive.setHex(newColor);
                                star.mesh.material.emissiveIntensity = 0.5; 
                                if (star.glowSprite) { 
                                    star.glowSprite.material.color.setHex(newColor);
                                }
                                updateDefenseRings(star); 
                                updateMineIndicators(star); 
                                updatePopulationIndicators(star);
                                updateShipyardIndicator(star); 
                                if (star.conquestRing) {
                                    scene.remove(star.conquestRing);
                                    star.conquestRing.geometry.dispose();
                                    star.conquestRing.material.dispose();
                                    star.conquestRing = null;
                                    }
                                star.conquestProgress = 0;
                                star.isBeingConqueredBy = null;
                                conqueringShips.forEach(s => s.state = 'orbiting'); 
                                if (selectedStar === star) handleStarClick(star); 
                            }
                        } else if (star.isBeingConqueredBy === conqueringFaction) { 
                            star.isBeingConqueredBy = null;
                        }
                         if (selectedStar === star) updateConquestProgressUI(star); 
                    }

                        /* ------- conquest-kehän päivitys ------- */
                        if (star.conquestRing) {
                        // • jos valloitus keskeytyi → poista kehä
                        if (star.isBeingConqueredBy === null) {
                            scene.remove(star.conquestRing);
                            star.conquestRing.geometry.dispose();
                            star.conquestRing.material.dispose();
                            star.conquestRing = null;
                        } else {
                            // • päivitä kaaren pituus
                            const pct   = THREE.MathUtils.clamp(star.conquestProgress / 100, 0, 1);
                            const len   = Math.max(0.0001, pct * Math.PI * 2);          // thetaLength
                            const baseR = star.conquestRing.userData.baseR;
                            // korvaa geometria uudella, jossa sama radius mutta pidempi kaari
                            star.conquestRing.geometry.dispose();
                            star.conquestRing.geometry = new THREE.RingGeometry(
                                baseR - 4, baseR + 1, 64, 1, 0, len);
                        }
                    }
                });
            }
            nebulaSprites.forEach(sp => {
                sp.quaternion.copy(camera.quaternion); // billboard-efekti
            });

            // ---- Shipyard-renkaiden gyropäivitys --------------------
            stars.forEach(star => {
                if (!star.shipyardRings) return;
                star.shipyardRings.forEach(ring => {
                    const s = ring.userData.spin;          // nopeus-vektorit
                    if (!s) return;
                    ring.rotation.x += s.x * delta;
                    ring.rotation.y += s.y * delta;
                    ring.rotation.z += s.z * delta;
                });
            });

            if (renderer && scene && camera) { 
                 composer.render();
            }
        }

        /* =======  COMBAT HELPERS  ======= */
        function applyDamage(ship, dmg, starOfCombat) {
            ship.hp -= dmg;
            if (ship.hp <= 0) destroyShips([ship], starOfCombat);
        }

        function pickTarget(list, predicate = () => true) {
            // Palauttaa heikoimman (alin HP) aluksen, joka täyttää predikaatin
            return list.filter(predicate).sort((a,b)=>a.hp-b.hp)[0] || null;
        }

        function damagePlanetaryDefense(star, dmg) {
            if (!star || star.defenseHP <= 0) return;
            star.defenseHP = Math.max(0, star.defenseHP - dmg);

            /* päivitä näkyvä taso, jos HP putosi seuraavan kynnyksen alle */
            const newLvl = Math.ceil(star.defenseHP / DEFENSE_HP_PER_LEVEL);
            if (newLvl !== star.defenseLevel) {
                star.defenseLevel = newLvl;
                updateDefenseRings(star);
            }
        }

        /**
         * Koittaa vahingoittaa planetary defenseiä.
         * @param {Object} star        – kohdeplaneetta
         * @param {string} shooterOwner– ampujan owner ('player' tai 'enemy')
         * @param {string} shooterType – merkkijono logia varten ("Fighter", ...)
         * @param {number} dmgPerShot  – osuman vahinko
         * @returns {boolean}  true jos PD vaurioitui (eli PD on olemassa ja shooterOwner != star.owner)
         */
        function tryDamagePD(star, shooterOwner, shooterType, dmgPerShot) {
            // Vain vihollisalukset voi vahingoittaa PD:tä
            if (typeof dmgPerShot !== 'number' || !isFinite(dmgPerShot)) return false;
            if (star.defenseHP <= 0 || shooterOwner === star.owner) return false;

            // Vaurioita PD:tä
            damagePlanetaryDefense(star, dmgPerShot);
            console.log(`${shooterType} hits PD (-${dmgPerShot}) on ${star.name}`);
            return true;
        }

        function resolveCombatAtStar(star) {
            if (!star) return;

            /* --------------------------------------------------
            0)  Alkutilanne + piirityksen purku
            -------------------------------------------------- */
            const allShipsAtStar = getShipsAtStar(star);
            const factionShips = {};
            
            // Group ships by faction
            allShipsAtStar.forEach(ship => {
                if (!factionShips[ship.owner]) {
                    factionShips[ship.owner] = [];
                }
                factionShips[ship.owner].push(ship);
            });
            
            const factions = Object.keys(factionShips);
            
            // If multiple factions present, cancel any conquest
            if (factions.length > 1 && star.isBeingConqueredBy) {
                star.isBeingConqueredBy = null;
                star.conquestProgress = 0;
                allShipsAtStar.forEach(s => { if (s.state === 'conquering') s.state = 'orbiting'; });
                if (selectedStar === star) updateConquestProgressUI(star);
            }
            
            // No combat if only one faction
            if (factions.length === 0) return;          // ei _mitään_ aluksia → turha jatkaa

            /* --------------------------------------------------
            1)  Defenderin PD-"first-strike"
            -------------------------------------------------- */
            if (star.defenseLevel > 0 && star.owner) {
                const shots = star.defenseLevel * 3;

                /* — apu: kohde- > vahinko — */
                const defendersPDdamage = tgt => (tgt.type === 'Cruiser') ? 0.3 : 2;

                /* ammutaan vihollisiin */
                const enemyShips = allShipsAtStar.filter(s => s.owner !== star.owner);

                for (let i = 0; i < shots && enemyShips.length; i++) {
                    const tgt =
                        pickTarget(enemyShips, s => s.type === 'Fighter')
                    || pickTarget(enemyShips, s => s.type === 'Destroyer')
                    || pickTarget(enemyShips);                        // mikä tahansa

                    if (tgt) applyDamage(tgt, defendersPDdamage(tgt), star);
                }
            }
            /* 1b) Jos paikalla on vain hyökkääjä + PD -------------- */
            if (factions.length === 1 && star.defenseHP > 0) {
                const attackers = factionShips[factions[0]];
                attackers.forEach(sh => {
                    if (sh.type === 'Cruiser')
                        tryDamagePD(star, sh.owner, 'Cruiser', CRUISER_DMG_VS_DEFENSE);
                    else if (sh.type === 'Destroyer')
                        tryDamagePD(star, sh.owner, 'Destroyer', DESTROYER_DMG_VS_DEFENSE);
                    else if (sh.type === 'Fighter')
                        tryDamagePD(star, sh.owner, 'Fighter',  FIGHTER_DMG_VS_DEFENSE);
                });
                // ei lähitaistelua, joten voidaan lopettaa tähän
                return;
            }   

            // -------------------------------------------------- */
            /* 2)  Multi-faction combat  –  järjestettynä tulilinjana  */

            const factionIds = Object.keys(factionShips);

            /* --- 2a  Cruiserit --- (pysyy entisellään) */
            factionIds.forEach(att => {
            const cruisers = factionShips[att].filter(s => s.type === 'Cruiser');
            factionIds.forEach(def => {
                if (att === def) return;
                const defenders = factionShips[def];
                cruisers.forEach(cr => {
                if (tryDamagePD(star, cr.owner, 'Cruiser', CRUISER_DMG_VS_DEFENSE)) return;
                const tgt = pickTarget(defenders, s => s.type === 'Destroyer')
                        || pickTarget(defenders);
                if (tgt) applyDamage(tgt, (tgt.type === 'Fighter') ? 0.5 : 2, star);
                });
            });
            });

            /* --- 2b  Destroyerit – FIRST STRIKE --- */
            factionIds.forEach(att => {
            const destroyers = factionShips[att].filter(s => s.type === 'Destroyer');
            factionIds.forEach(def => {
                if (att === def) return;
                const defenders = factionShips[def];
                destroyers.forEach(de => {
                for (let i = 0; i < 2; i++) {
                    if (tryDamagePD(star, de.owner, 'Destroyer', DESTROYER_DMG_VS_DEFENSE)) continue;
                    const tgt = pickTarget(defenders, s => s.type === 'Fighter')
                            || pickTarget(defenders);
                    if (tgt) applyDamage(tgt, 1, star);
                }
                });
            });
            });

            /* --- 2c  Fighterit --- */
            factionIds.forEach(att => {
            const fighters = factionShips[att].filter(s => s.type === 'Fighter');
            factionIds.forEach(def => {
                if (att === def) return;
                const defenders = factionShips[def];
                fighters.forEach(fi => {
                if (tryDamagePD(star, fi.owner, 'Fighter', FIGHTER_DMG_VS_DEFENSE)) return;
                const tgt = pickTarget(defenders);
                if (!tgt) return;
                const dmg = (tgt.type === 'Cruiser') ? 1.35 : 1;
                applyDamage(tgt, dmg, star);
                });
            });
            });

            /* --------------------------------------------------
            3)  Lähitaistelu (vain jos PD tuhottu)
            -------------------------------------------------- */
            if (star.defenseHP <= 0 && factions.length > 1) {
                // Simple melee: each faction damages one ship from each other faction
                factions.forEach((faction1, i) => {
                    factions.forEach((faction2, j) => {
                        if (i >= j) return; // Avoid double damage
                        
                        const ships1 = factionShips[faction1].filter(s => allShips.includes(s));
                        const ships2 = factionShips[faction2].filter(s => allShips.includes(s));
                        
                        if (ships1.length && ships2.length) {
                            applyDamage(ships1[0], 1, star);
                            applyDamage(ships2[0], 1, star);
                        }
                    });
                });
            }

            if (selectedStar === star) handleStarClick(star); // UI-päivitys
        }




        function destroyShips(shipsToDestroy, starOfCombat) {
            shipsToDestroy.forEach(ship => {
                if (ship.mesh){
                    /* pieni partikkeliräjähdys */
                    spawnExplosion(ship.mesh.position);
                    scene.remove(ship.mesh);
                    }
                
                const globalIndex = allShips.findIndex(s => s.id === ship.id);
                if (globalIndex > -1) allShips.splice(globalIndex, 1);

                if (ship.parentStar && ship.parentStar.orbitingShips) {
                     ship.parentStar.orbitingShips = ship.parentStar.orbitingShips.filter(s => s.id !== ship.id);
                }
                if (starOfCombat && starOfCombat.orbitingShips && starOfCombat !== ship.parentStar) {
                    starOfCombat.orbitingShips = starOfCombat.orbitingShips.filter(s => s.id !== ship.id);
                }


                const selectedIndex = selectedShips.findIndex(s => s.id === ship.id);
                if (selectedIndex > -1) selectedShips.splice(selectedIndex, 1);

                for (const groupKey in controlGroups) {
                    controlGroups[groupKey] = controlGroups[groupKey].filter(s => s.id !== ship.id);
                }
                //console.log(`Ship ${ship.id.substring(0,5)} (Owner: ${ship.owner}) destroyed at star ${starOfCombat.id.substring(0,5)}.`);
            });
            updateSelectedUnitsDisplay(); 
            updateGroupsPanel();
        }

        function updateDefenseRings(star) {
            if (!star || !star.mesh) return;

            if (star.defenseRings) {
                star.defenseRings.forEach(ring => scene.remove(ring));
            }
            star.defenseRings = [];

            if (star.owner !== 'neutral') { 
 
                /* 1)  valitaan perusväri */
                let ownerColor;
                if (star.owner === PLAYER_ID) {
                    ownerColor = PLAYER_COLOR;
                } else {
                    const ai = aiPlayers.find(p => p.id === star.owner);
                    ownerColor = ai ? ai.color : 0xdc3545;
                }

                /* 2)  sekoitetaan 60 % valkoista → vaaleampi sävy */
                const ringColor  = new THREE.Color(ownerColor)
                                    .lerp(new THREE.Color(0xffffff), 0.30);   // 0.60 = "kuinka valkea"

                /* 3)  materiaali – voit keventää myös opacity-arvoa halutessasi */
                const ringMaterial = new THREE.MeshBasicMaterial({
                    color      : ringColor,
                    side       : THREE.DoubleSide,
                    transparent: true,
                    opacity    : 0.85 + Math.min(star.defenseLevel * 0.12, 0.45)  // hiukan kevyempi
                });

                const starRadius = star.mesh.geometry.parameters.radius * (star.mesh.scale.x || 1);

                for (let i = 0; i < star.defenseLevel; i++) {
                    const ringRadius = starRadius + 3 + i * 1.5; 
                    const ringGeometry = new THREE.RingGeometry(ringRadius - 0.2, ringRadius + 0.2, 64);
                    const ring = new THREE.Mesh(ringGeometry, ringMaterial);
                    ring.position.copy(star.mesh.position);
                    ring.rotation.x = Math.PI / 2; 
                    scene.add(ring);
                    star.defenseRings.push(ring);
                }
            }
        }
        
        function updateMineIndicators(star) {
            if (!star || !star.mesh || !mineSpriteMaterial) return;
            if (star.mineIndicatorMeshes) {
                star.mineIndicatorMeshes.forEach(m => scene.remove(m));
            }
            star.mineIndicatorMeshes = [];

            if (star.owner !== 'neutral') {
                const starRadiusScaled = star.mesh.geometry.parameters.radius * (star.mesh.scale.x || 1);
                const itemsPerRow = 4; 
                const spacing = INDICATOR_SPRITE_SCALE * 0.9; 
                const yOffset = starRadiusScaled + INDICATOR_SPRITE_SCALE * 1.2 + (star.defenseRings.length > 0 ? (star.defenseRings.length * 1.5 + 1.2) : 0) ; 
                const xBaseOffset = starRadiusScaled * 0.6 + INDICATOR_SPRITE_SCALE * 0.4; 

                for (let i = 0; i < star.mines; i++) {
                    const sprite = new THREE.Sprite(mineSpriteMaterial.clone()); 
                    let indicatorBaseColor;
                    if (star.owner === PLAYER_ID) {
                        indicatorBaseColor = new THREE.Color(PLAYER_COLOR);
                    } else {
                        const ai = aiPlayers.find(p => p.id === star.owner);
                        indicatorBaseColor = ai ? new THREE.Color(ai.color) : new THREE.Color(0xdc3545);
                    }
                    sprite.material.color.copy(indicatorBaseColor).lerp(new THREE.Color(0xffffff), 0.5);  
                    sprite.scale.set(INDICATOR_SPRITE_SCALE, INDICATOR_SPRITE_SCALE, 1);
                    
                    const row = Math.floor(i / itemsPerRow);
                    const col = i % itemsPerRow;
                    
                    sprite.position.set(
                        star.mesh.position.x + xBaseOffset + (col * spacing),
                        star.mesh.position.y + yOffset, 
                        star.mesh.position.z + (row * spacing * 0.9) - ((Math.floor(star.maxMines / itemsPerRow) * spacing * 0.9) / 2) 
                    );
                    scene.add(sprite);
                    star.mineIndicatorMeshes.push(sprite);
                }
            }
        }

        function updatePopulationIndicators(star) {
            if (!star || !star.mesh || !popSpriteMaterial) return;
            if (star.populationIndicatorMeshes) {
                star.populationIndicatorMeshes.forEach(p => scene.remove(p));
            }
            star.populationIndicatorMeshes = [];

            if (star.owner !== 'neutral') {
                const starRadiusScaled = star.mesh.geometry.parameters.radius * (star.mesh.scale.x || 1);
                const itemsPerRow = 4;
                const spacing = INDICATOR_SPRITE_SCALE * 0.9;
                const yOffset = starRadiusScaled + INDICATOR_SPRITE_SCALE * 1.2 + (star.defenseRings.length > 0 ? (star.defenseRings.length * 1.5 + 1.2) : 0); 
                const xBaseOffset = - (starRadiusScaled * 0.6 + INDICATOR_SPRITE_SCALE * 0.4); 


                for (let i = 0; i < star.population; i++) {
                    const sprite = new THREE.Sprite(popSpriteMaterial.clone());
                    let indicatorBaseColor;
                    if (star.owner === PLAYER_ID) {
                        indicatorBaseColor = new THREE.Color(PLAYER_COLOR);
                    } else {
                        const ai = aiPlayers.find(p => p.id === star.owner);
                        indicatorBaseColor = ai ? new THREE.Color(ai.color) : new THREE.Color(0xdc3545);
                    }
                    sprite.material.color.copy(indicatorBaseColor).lerp(new THREE.Color(0xffffff), 0.5);
                    sprite.scale.set(INDICATOR_SPRITE_SCALE, INDICATOR_SPRITE_SCALE, 1);

                    const row = Math.floor(i / itemsPerRow);
                    const col = i % itemsPerRow;

                    sprite.position.set(
                        star.mesh.position.x + xBaseOffset - (col * spacing),
                        star.mesh.position.y + yOffset, 
                        star.mesh.position.z + (row * spacing * 0.9) - ((Math.floor(star.maxPopulation / itemsPerRow) * spacing * 0.9) / 2) 
                    );
                    scene.add(sprite);
                    star.populationIndicatorMeshes.push(sprite);
                }
            }
        }

        function updateShipyardIndicator(star) {
            if (!star || !star.mesh || !shipyardSpriteMaterial) return;

            /* 1) Siivoa vanhat */
            if (star.shipyardIndicatorSprite) scene.remove(star.shipyardIndicatorSprite);
            if (star.shipyardRings) star.shipyardRings.forEach(r => scene.remove(r));

            star.shipyardIndicatorSprite = null;
            star.shipyardRings = [];

            /* 2) Lisää, jos telakkaa vähintään Lvl 1 */
            if (star.shipyardLevel === 0 || star.owner === 'neutral') return;

            /* --- Telakka-sprite --- */
            const starRadius = star.mesh.geometry.parameters.radius * (star.mesh.scale.x || 1);
            const yOffset = starRadius + INDICATOR_SPRITE_SCALE * 1.5 +
                (star.defenseRings.length ? star.defenseRings.length * 1.5 + 1.0 : 0);

            const sprite = new THREE.Sprite(shipyardSpriteMaterial.clone());
            let baseColor;
            if (star.owner === PLAYER_ID) {
                baseColor = PLAYER_COLOR;
            } else {
                const ai = aiPlayers.find(p => p.id === star.owner);
                baseColor = ai ? ai.color : 0xdc3545;
            }
            sprite.material.color.set(baseColor).lerp(new THREE.Color(0xffffff), 0.3);
            sprite.scale.setScalar(INDICATOR_SPRITE_SCALE * 1.8);
            sprite.position.set(
                star.mesh.position.x,
                star.mesh.position.y + yOffset,
                star.mesh.position.z - starRadius * 0.8 - INDICATOR_SPRITE_SCALE * 1.8
            );
            scene.add(sprite);
            star.shipyardIndicatorSprite = sprite;

            /* --- Kiertorata-renkaat --- */
            const tubeRadius = 0.25;
            const baseRadius = starRadius + INDICATOR_SPRITE_SCALE * 3;

            // LISÄTTY TASO 4 TÄNNE!
            const ringTilts = [
                /* Lvl 1 */ new THREE.Euler(THREE.MathUtils.degToRad(45), 0, 0),
                /* Lvl 2 */ new THREE.Euler(0, THREE.MathUtils.degToRad(-45), 0),
                /* Lvl 3 */ new THREE.Euler(0, 0, THREE.MathUtils.degToRad(-45)),
                /* Lvl 4 */ new THREE.Euler(THREE.MathUtils.degToRad(90), 0, 0) // Uusi rengas pystysuoraan
            ];

            const radialSegs = 32;
            const tubularSegs = 256;

            for (let lvl = 1; lvl <= star.shipyardLevel; lvl++) {
                const ringGeom = new THREE.TorusGeometry(
                    baseRadius, tubeRadius, radialSegs, tubularSegs
                );
                const ringMat = new THREE.MeshBasicMaterial({
                    color: 0xffffff, transparent: true, opacity: 0.9, toneMapped: false
                });
                const ring = new THREE.Mesh(ringGeom, ringMat);

                // Varmistetaan, että emme yritä hakea arvoa taulukon ulkopuolelta
                if (ringTilts[lvl - 1]) {
                    ring.rotation.copy(ringTilts[lvl - 1]);
                }

                const speed = 0.35;
                ring.userData.spin = {
                    x: lvl === 2 ? speed : 0,
                    y: (lvl === 1 || lvl === 3) ? speed : (lvl === 4 ? -speed : 0), // Lvl 4 pyörii vastakkaiseen suuntaan
                    z: 0
                };

                ring.position.copy(star.mesh.position);
                scene.add(ring);
                star.shipyardRings.push(ring);
            }
        }
        
        // Centralized function to update star visuals based on hover/selection
        function updateAllStarVisuals() {
            // Reset all highlights first
            stars.forEach(star => {
                if (star.glowSprite) {
                    const baseGlowSize = star.mesh.geometry.parameters.radius * STAR_GLOW_DEFAULT_SCALE * (star.isHomeworld ? 1.6 : 1.0);
                    star.glowSprite.material.opacity = STAR_GLOW_DEFAULT_OPACITY;
                    star.glowSprite.scale.set(baseGlowSize, baseGlowSize, 1);
                }
            });
            starConnections.forEach(line => {
                if (line.material) {
                    line.material.opacity = STAR_LANE_DEFAULT_OPACITY;
                }
            });

            // Apply hover highlights
            if (hoveredStar && hoveredStar !== selectedStar) {
                if (hoveredStar.glowSprite) {
                    hoveredStar.glowSprite.material.opacity = STAR_GLOW_HOVER_OPACITY;
                    const hoverGlowSize = hoveredStar.mesh.geometry.parameters.radius * STAR_GLOW_DEFAULT_SCALE * (hoveredStar.isHomeworld ? 1.6 : 1.0) * STAR_GLOW_HOVER_SCALE_FACTOR;
                    hoveredStar.glowSprite.scale.set(hoverGlowSize, hoverGlowSize, 1);
                }
                highlightStarLanes(hoveredStar, 'hover');
            }

            // Apply selection highlights (overrides hover if same star)
            if (selectedStar) {
                if (selectedStar.glowSprite) {
                    selectedStar.glowSprite.material.opacity = STAR_GLOW_SELECTED_OPACITY;
                    const selectedGlowSize = selectedStar.mesh.geometry.parameters.radius * STAR_GLOW_DEFAULT_SCALE * (selectedStar.isHomeworld ? 1.6 : 1.0) * STAR_GLOW_SELECTED_SCALE_FACTOR;
                    selectedStar.glowSprite.scale.set(selectedGlowSize, selectedGlowSize, 1);
                }
                highlightStarLanes(selectedStar, 'selected');
            }
        }

        // Helper function to highlight star lanes and connected stars
        function highlightStarLanes(star, highlightState) {
            if (!star) return;

            const laneOpacity = highlightState === 'selected' ? STAR_LANE_SELECTED_OPACITY : STAR_LANE_HOVER_OPACITY;
            const connectedStarOpacity = highlightState === 'selected' ? CONNECTED_STAR_SELECTED_GLOW_OPACITY : CONNECTED_STAR_HOVER_GLOW_OPACITY;

            starConnections.forEach(line => {
                if (line.userData.star1Id === star.id || line.userData.star2Id === star.id) {
                    if (line.material) {
                        line.material.opacity = laneOpacity;
                    }
                    // Highlight the connected star (if it's not the selected/hovered one itself)
                    const connectedStarId = line.userData.star1Id === star.id ? line.userData.star2Id : line.userData.star1Id;
                    const connectedStar = stars.find(s => s.id === connectedStarId);
                    // Only apply hover/select glow if the connected star isn't already selected
                    if (connectedStar && connectedStar !== selectedStar && connectedStar.glowSprite) {
                         // Apply highlight only if its current opacity is the default
                         if (connectedStar.glowSprite.material.opacity === STAR_GLOW_DEFAULT_OPACITY) {
                             connectedStar.glowSprite.material.opacity = connectedStarOpacity;
                         }
                    }
                }
            });
        }

        window.stars = stars; // Export stars for AI logic

        init();

    </script>
    <div id="custom-tooltip" style="display: none;"></div>
</body>
</html>